(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "tslib", "./Pointer", "./compare"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require("tslib");
    var Pointer_1 = require("./Pointer");
    var compare_1 = require("./compare");
    var OperationType;
    (function (OperationType) {
        OperationType["ADD"] = "add";
        OperationType["REMOVE"] = "remove";
        OperationType["REPLACE"] = "replace";
        OperationType["TEST"] = "test";
    })(OperationType = exports.OperationType || (exports.OperationType = {}));
    function add(pointerTarget, value) {
        if (Array.isArray(pointerTarget.target)) {
            pointerTarget.target.splice(parseInt(pointerTarget.segment, 10), 0, value);
        }
        else {
            pointerTarget.target[pointerTarget.segment] = value;
        }
        return pointerTarget.object;
    }
    function replace(pointerTarget, value) {
        if (Array.isArray(pointerTarget.target)) {
            pointerTarget.target.splice(parseInt(pointerTarget.segment, 10), 1, value);
        }
        else {
            pointerTarget.target[pointerTarget.segment] = value;
        }
        return pointerTarget.object;
    }
    function remove(pointerTarget) {
        if (Array.isArray(pointerTarget.target)) {
            pointerTarget.target.splice(parseInt(pointerTarget.segment, 10), 1);
        }
        else {
            delete pointerTarget.target[pointerTarget.segment];
        }
        return pointerTarget.object;
    }
    function inverse(operation, state) {
        if (operation.op === OperationType.ADD) {
            var op = {
                op: OperationType.REMOVE,
                path: operation.path
            };
            var test = {
                op: OperationType.TEST,
                path: operation.path,
                value: operation.value
            };
            return [test, op];
        }
        else if (operation.op === OperationType.REPLACE) {
            var value = operation.path.get(state);
            var op = void 0;
            if (value === undefined) {
                op = {
                    op: OperationType.REMOVE,
                    path: operation.path
                };
            }
            else {
                op = {
                    op: OperationType.REPLACE,
                    path: operation.path,
                    value: operation.path.get(state)
                };
            }
            var test = {
                op: OperationType.TEST,
                path: operation.path,
                value: operation.value
            };
            return [test, op];
        }
        else {
            return [
                {
                    op: OperationType.ADD,
                    path: operation.path,
                    value: operation.path.get(state)
                }
            ];
        }
    }
    var Patch = /** @class */ (function () {
        function Patch(operations) {
            this._operations = Array.isArray(operations) ? operations : [operations];
        }
        Patch.prototype.apply = function (object) {
            var undoOperations = [];
            var patchedObject = this._operations.reduce(function (patchedObject, next) {
                var object;
                var pointerTarget = Pointer_1.walk(next.path.segments, patchedObject);
                switch (next.op) {
                    case OperationType.ADD:
                        object = add(pointerTarget, next.value);
                        break;
                    case OperationType.REPLACE:
                        object = replace(pointerTarget, next.value);
                        break;
                    case OperationType.REMOVE:
                        object = remove(pointerTarget);
                        break;
                    case OperationType.TEST:
                        var current = pointerTarget.target[pointerTarget.segment];
                        if (!compare_1.isEqual(current, next.value)) {
                            var location_1 = next.path.path;
                            throw new Error("Test operation failure at \"" + location_1 + "\". " + compare_1.getFriendlyDifferenceMessage(next.value, current) + ".");
                        }
                        return patchedObject;
                    default:
                        throw new Error('Unknown operation');
                }
                undoOperations = tslib_1.__spread(inverse(next, patchedObject), undoOperations);
                return object;
            }, object);
            return { object: patchedObject, undoOperations: undoOperations };
        };
        return Patch;
    }());
    exports.Patch = Patch;
});
//# sourceMappingURL=Patch.js.map