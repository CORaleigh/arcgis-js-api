(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "tslib", "../shim/Promise", "../shim/Map", "../has/has"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require("tslib");
    var Promise_1 = require("../shim/Promise");
    var Map_1 = require("../shim/Map");
    var has_1 = require("../has/has");
    /**
     * Creates a command factory with the specified type
     */
    function createCommandFactory() {
        return function (command) { return command; };
    }
    exports.createCommandFactory = createCommandFactory;
    var processMap = new Map_1.default();
    function getProcess(id) {
        return processMap.get(id);
    }
    exports.getProcess = getProcess;
    function processExecutor(id, commands, store, before, after, transformer) {
        var _this = this;
        var apply = store.apply, get = store.get, path = store.path, at = store.at;
        function executor(process, payload, transformer) {
            return process(store)(payload);
        }
        return function (executorPayload) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var operations, commandsCopy, undoOperations, command, error, payload, result, results, result, i, e_1;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        operations = [];
                        commandsCopy = tslib_1.__spread(commands);
                        undoOperations = [];
                        command = commandsCopy.shift();
                        error = null;
                        payload = transformer ? transformer(executorPayload) : executorPayload;
                        if (!before) return [3 /*break*/, 2];
                        result = before(payload, store);
                        if (!result) return [3 /*break*/, 2];
                        return [4 /*yield*/, result];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2:
                        _a.trys.push([2, 10, , 11]);
                        _a.label = 3;
                    case 3:
                        if (!command) return [3 /*break*/, 9];
                        results = [];
                        if (!Array.isArray(command)) return [3 /*break*/, 5];
                        results = command.map(function (commandFunction) { return commandFunction({ at: at, get: get, path: path, payload: payload }); });
                        return [4 /*yield*/, Promise.all(results)];
                    case 4:
                        results = _a.sent();
                        return [3 /*break*/, 8];
                    case 5:
                        result = command({ at: at, get: get, path: path, payload: payload });
                        if (!Promise_1.isThenable(result)) return [3 /*break*/, 7];
                        return [4 /*yield*/, result];
                    case 6:
                        result = _a.sent();
                        _a.label = 7;
                    case 7:
                        results = [result];
                        _a.label = 8;
                    case 8:
                        for (i = 0; i < results.length; i++) {
                            operations.push.apply(operations, tslib_1.__spread(results[i]));
                            undoOperations = tslib_1.__spread(apply(results[i]), undoOperations);
                        }
                        store.invalidate();
                        command = commandsCopy.shift();
                        return [3 /*break*/, 3];
                    case 9: return [3 /*break*/, 11];
                    case 10:
                        e_1 = _a.sent();
                        error = { error: e_1, command: command };
                        return [3 /*break*/, 11];
                    case 11:
                        after &&
                            after(error, {
                                undoOperations: undoOperations,
                                store: store,
                                id: id,
                                operations: operations,
                                apply: apply,
                                at: at,
                                get: get,
                                path: path,
                                executor: executor,
                                payload: payload
                            });
                        return [2 /*return*/, Promise.resolve({
                                store: store,
                                undoOperations: undoOperations,
                                id: id,
                                error: error,
                                operations: operations,
                                apply: apply,
                                at: at,
                                get: get,
                                path: path,
                                executor: executor,
                                payload: payload
                            })];
                }
            });
        }); };
    }
    exports.processExecutor = processExecutor;
    /**
     * Factories a process using the provided commands and an optional callback. Returns an executor used to run the process.
     *
     * @param commands The commands for the process
     * @param callback Callback called after the process is completed
     */
    function createProcess(id, commands, callbacks) {
        callbacks = Array.isArray(callbacks) ? callbacks : callbacks ? [callbacks] : [];
        var callback = callbacks.length
            ? callbacks.reduce(function (callback, nextCallback) {
                return combineCallbacks(nextCallback)(callback);
            })
            : undefined;
        var _a = callback ? callback() : {}, _b = _a.before, before = _b === void 0 ? undefined : _b, _c = _a.after, after = _c === void 0 ? undefined : _c;
        processMap.set(id, [id, commands, before, after]);
        return function (store, transformer) {
            return processExecutor(id, commands, store, before, after, transformer);
        };
    }
    exports.createProcess = createProcess;
    /**
     * Creates a process factory that will create processes with the specified callback decorators applied.
     * @param callbacks array of process callback to be used by the returned factory.
     * @param initializers array of process initializers to be used by the returned factory.
     */
    function createProcessFactoryWith(callbacks) {
        return function (id, commands, callback) {
            return createProcess(id, commands, callback ? tslib_1.__spread(callbacks, [callback]) : callbacks);
        };
    }
    exports.createProcessFactoryWith = createProcessFactoryWith;
    /**
     * Creates a `ProcessCallbackDecorator` from a `ProcessCallback`.
     * @param processCallback the process callback to convert to a decorator.
     */
    function combineCallbacks(processCallback) {
        var _a = processCallback(), before = _a.before, after = _a.after;
        return function (previousCallback) {
            var _a = previousCallback
                ? previousCallback()
                : {}, _b = _a.before, previousBefore = _b === void 0 ? undefined : _b, _c = _a.after, previousAfter = _c === void 0 ? undefined : _c;
            return function () { return ({
                after: function (error, result) {
                    if (previousAfter) {
                        previousAfter(error, result);
                    }
                    if (after) {
                        after(error, result);
                    }
                },
                before: function (payload, store) {
                    if (previousBefore) {
                        previousBefore(payload, store);
                    }
                    if (before) {
                        before(payload, store);
                    }
                }
            }); };
        };
    }
    function createCallbackDecorator(callback) {
        if (has_1.default('dojo-debug')) {
            console.warn('Process using the the legacy middleware API. Please update to use the latest API, see https://github.com/dojo/framework/blob/master/docs/V5-Migration-Guide.md for details.');
        }
        var convertedCallback = function () { return ({
            after: callback
        }); };
        return function (callbacks) {
            if (callbacks === void 0) { callbacks = []; }
            return tslib_1.__spread([convertedCallback], callbacks);
        };
    }
    exports.createCallbackDecorator = createCallbackDecorator;
});
//# sourceMappingURL=process.js.map