import * as tslib_1 from "tslib";
import { isThenable } from '../shim/Promise';
import Map from '../shim/Map';
import has from '../has/has';
/**
 * Creates a command factory with the specified type
 */
export function createCommandFactory() {
    return (command) => command;
}
const processMap = new Map();
export function getProcess(id) {
    return processMap.get(id);
}
export function processExecutor(id, commands, store, before, after, transformer) {
    const { apply, get, path, at } = store;
    function executor(process, payload, transformer) {
        return process(store)(payload);
    }
    return (executorPayload) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        const operations = [];
        const commandsCopy = [...commands];
        let undoOperations = [];
        let command = commandsCopy.shift();
        let error = null;
        const payload = transformer ? transformer(executorPayload) : executorPayload;
        if (before) {
            let result = before(payload, store);
            if (result) {
                yield result;
            }
        }
        try {
            while (command) {
                let results = [];
                if (Array.isArray(command)) {
                    results = command.map((commandFunction) => commandFunction({ at, get, path, payload }));
                    results = yield Promise.all(results);
                }
                else {
                    let result = command({ at, get, path, payload });
                    if (isThenable(result)) {
                        result = yield result;
                    }
                    results = [result];
                }
                for (let i = 0; i < results.length; i++) {
                    operations.push(...results[i]);
                    undoOperations = [...apply(results[i]), ...undoOperations];
                }
                store.invalidate();
                command = commandsCopy.shift();
            }
        }
        catch (e) {
            error = { error: e, command };
        }
        after &&
            after(error, {
                undoOperations,
                store,
                id,
                operations,
                apply,
                at,
                get,
                path,
                executor,
                payload
            });
        return Promise.resolve({
            store,
            undoOperations,
            id,
            error,
            operations,
            apply,
            at,
            get,
            path,
            executor,
            payload
        });
    });
}
/**
 * Factories a process using the provided commands and an optional callback. Returns an executor used to run the process.
 *
 * @param commands The commands for the process
 * @param callback Callback called after the process is completed
 */
export function createProcess(id, commands, callbacks) {
    callbacks = Array.isArray(callbacks) ? callbacks : callbacks ? [callbacks] : [];
    const callback = callbacks.length
        ? callbacks.reduce((callback, nextCallback) => {
            return combineCallbacks(nextCallback)(callback);
        })
        : undefined;
    const { before = undefined, after = undefined } = callback ? callback() : {};
    processMap.set(id, [id, commands, before, after]);
    return (store, transformer) => processExecutor(id, commands, store, before, after, transformer);
}
/**
 * Creates a process factory that will create processes with the specified callback decorators applied.
 * @param callbacks array of process callback to be used by the returned factory.
 * @param initializers array of process initializers to be used by the returned factory.
 */
export function createProcessFactoryWith(callbacks) {
    return (id, commands, callback) => {
        return createProcess(id, commands, callback ? [...callbacks, callback] : callbacks);
    };
}
/**
 * Creates a `ProcessCallbackDecorator` from a `ProcessCallback`.
 * @param processCallback the process callback to convert to a decorator.
 */
function combineCallbacks(processCallback) {
    const { before, after } = processCallback();
    return (previousCallback) => {
        const { before: previousBefore = undefined, after: previousAfter = undefined } = previousCallback
            ? previousCallback()
            : {};
        return () => ({
            after(error, result) {
                if (previousAfter) {
                    previousAfter(error, result);
                }
                if (after) {
                    after(error, result);
                }
            },
            before(payload, store) {
                if (previousBefore) {
                    previousBefore(payload, store);
                }
                if (before) {
                    before(payload, store);
                }
            }
        });
    };
}
export function createCallbackDecorator(callback) {
    if (has('dojo-debug')) {
        console.warn('Process using the the legacy middleware API. Please update to use the latest API, see https://github.com/dojo/framework/blob/master/docs/V5-Migration-Guide.md for details.');
    }
    const convertedCallback = () => ({
        after: callback
    });
    return (callbacks = []) => {
        return [convertedCallback, ...callbacks];
    };
}
//# sourceMappingURL=process.mjs.map