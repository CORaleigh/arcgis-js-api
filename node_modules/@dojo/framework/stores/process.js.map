{"version":3,"file":"process.js","sourceRoot":"","sources":["process.ts"],"names":[],"mappings":"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","sourcesContent":["import { isThenable } from '../shim/Promise';\nimport { PatchOperation } from './state/Patch';\nimport { State, Store } from './Store';\nimport Map from '../shim/Map';\nimport has from '../has/has';\n\n/**\n * Default Payload interface\n */\nexport interface DefaultPayload {\n\t[index: string]: any;\n}\n\n/**\n * The arguments passed to a `Command`\n */\nexport interface CommandRequest<T = any, P extends object = DefaultPayload> extends State<T> {\n\tpayload: P;\n}\n\n/**\n * A command factory interface. Returns the passed command. This provides a way to automatically infer and/or\n * verify the type of multiple commands without explicitly specifying the generic for each command\n */\nexport interface CommandFactory<T = any, P extends object = DefaultPayload> {\n\t<R extends object = P>(command: Command<T, R>): Command<T, R>;\n}\n\n/**\n * Command that returns patch operations based on the command request\n */\nexport interface Command<T = any, P extends object = DefaultPayload> {\n\t(request: CommandRequest<T, P>): Promise<PatchOperation<T>[]> | PatchOperation<T>[];\n}\n\n/**\n * Transformer function\n */\nexport interface Transformer<P extends object = DefaultPayload, R extends object = DefaultPayload> {\n\t(payload: R): P;\n}\n\n/**\n * A process that returns an executor using a Store and Transformer\n */\nexport interface Process<T = any, P extends object = DefaultPayload> {\n\t<R extends object = DefaultPayload>(store: Store<T>, transformer: Transformer<P, R>): ProcessExecutor<T, P, R>;\n\t(store: Store<T>): ProcessExecutor<T, P, P>;\n}\n\n/**\n * Represents an error from a ProcessExecutor\n */\nexport interface ProcessError<T = any> {\n\terror: Error | null;\n\tcommand?: Command<T, any>[] | Command<T, any>;\n}\n\nexport interface ProcessResultExecutor<T = any> {\n\t<P extends object = DefaultPayload, R extends object = DefaultPayload>(\n\t\tprocess: Process<T, P>,\n\t\tpayload: R,\n\t\ttransformer: Transformer<P, R>\n\t): Promise<ProcessResult<T, P> | ProcessError<T>>;\n\t<P extends object = object>(process: Process<T, P>, payload: P): Promise<ProcessResult<T, P> | ProcessError<T>>;\n}\n\n/**\n * Represents a successful result from a ProcessExecutor\n */\nexport interface ProcessResult<T = any, P extends object = DefaultPayload> extends State<T> {\n\texecutor: ProcessResultExecutor<T>;\n\tstore: Store<T>;\n\toperations: PatchOperation<T>[];\n\tundoOperations: PatchOperation<T>[];\n\tapply: (operations: PatchOperation<T>[], invalidate?: boolean) => PatchOperation<T>[];\n\tpayload: P;\n\tid: string;\n\terror?: ProcessError<T> | null;\n}\n\n/**\n * Runs a process for the given arguments.\n */\nexport interface ProcessExecutor<T = any, P extends object = DefaultPayload, R extends object = DefaultPayload> {\n\t(payload: R): Promise<ProcessResult<T, P>>;\n}\n\nexport interface ProcessCallback<T = any, P extends object = DefaultPayload> {\n\t(): {\n\t\tbefore?: ProcessCallbackBefore<T, P>;\n\t\tafter?: ProcessCallbackAfter<T>;\n\t};\n}\n\n/**\n * Callback for a process, returns an error as the first argument\n */\nexport interface ProcessCallbackAfter<T = any> {\n\t(error: ProcessError<T> | null, result: ProcessResult<T>): void;\n}\n\nexport interface ProcessCallbackBefore<T = any, P extends object = DefaultPayload> {\n\t(payload: P, store: Store<T>): void | Promise<void>;\n}\n\n/**\n * Function for undoing operations\n */\nexport interface Undo {\n\t(): void;\n}\n\n/**\n * ProcessCallbackDecorator callback\n */\ninterface ProcessCallbackDecorator {\n\t(callback?: ProcessCallback): ProcessCallback;\n}\n\n/**\n * CreateProcess factory interface\n */\nexport interface CreateProcess<T = any, P extends object = DefaultPayload> {\n\t(id: string, commands: (Command<T, P>[] | Command<T, P>)[], callback?: ProcessCallback<T>): Process<T, P>;\n}\n\n/**\n * Creates a command factory with the specified type\n */\nexport function createCommandFactory<T, P extends object = DefaultPayload>(): CommandFactory<T, P> {\n\treturn <R extends object = P>(command: Command<T, R>) => command;\n}\n\n/**\n * Commands that can be passed to a process\n */\nexport type Commands<T = any, P extends object = DefaultPayload> = (Command<T, P>[] | Command<T, P>)[];\n\nconst processMap = new Map();\n\nexport function getProcess(id: string) {\n\treturn processMap.get(id);\n}\n\nexport function processExecutor<T = any, P extends object = DefaultPayload>(\n\tid: string,\n\tcommands: Commands<T, P>,\n\tstore: Store<T>,\n\tbefore: ProcessCallbackBefore | undefined,\n\tafter: ProcessCallbackAfter | undefined,\n\ttransformer: Transformer<P> | undefined\n): ProcessExecutor<T, any, any> {\n\tconst { apply, get, path, at } = store;\n\tfunction executor(\n\t\tprocess: Process,\n\t\tpayload: any,\n\t\ttransformer?: Transformer\n\t): Promise<ProcessResult | ProcessError> {\n\t\treturn process(store)(payload);\n\t}\n\n\treturn async (executorPayload: P): Promise<ProcessResult<T, P>> => {\n\t\tconst operations: PatchOperation[] = [];\n\t\tconst commandsCopy = [...commands];\n\t\tlet undoOperations: PatchOperation[] = [];\n\t\tlet command = commandsCopy.shift();\n\t\tlet error: ProcessError | null = null;\n\t\tconst payload = transformer ? transformer(executorPayload) : executorPayload;\n\n\t\tif (before) {\n\t\t\tlet result = before(payload, store);\n\t\t\tif (result) {\n\t\t\t\tawait result;\n\t\t\t}\n\t\t}\n\t\ttry {\n\t\t\twhile (command) {\n\t\t\t\tlet results = [];\n\t\t\t\tif (Array.isArray(command)) {\n\t\t\t\t\tresults = command.map((commandFunction) => commandFunction({ at, get, path, payload }));\n\t\t\t\t\tresults = await Promise.all(results);\n\t\t\t\t} else {\n\t\t\t\t\tlet result = command({ at, get, path, payload });\n\t\t\t\t\tif (isThenable(result)) {\n\t\t\t\t\t\tresult = await result;\n\t\t\t\t\t}\n\t\t\t\t\tresults = [result];\n\t\t\t\t}\n\n\t\t\t\tfor (let i = 0; i < results.length; i++) {\n\t\t\t\t\toperations.push(...results[i]);\n\t\t\t\t\tundoOperations = [...apply(results[i]), ...undoOperations];\n\t\t\t\t}\n\n\t\t\t\tstore.invalidate();\n\t\t\t\tcommand = commandsCopy.shift();\n\t\t\t}\n\t\t} catch (e) {\n\t\t\terror = { error: e, command };\n\t\t}\n\n\t\tafter &&\n\t\t\tafter(error, {\n\t\t\t\tundoOperations,\n\t\t\t\tstore,\n\t\t\t\tid,\n\t\t\t\toperations,\n\t\t\t\tapply,\n\t\t\t\tat,\n\t\t\t\tget,\n\t\t\t\tpath,\n\t\t\t\texecutor,\n\t\t\t\tpayload\n\t\t\t});\n\t\treturn Promise.resolve({\n\t\t\tstore,\n\t\t\tundoOperations,\n\t\t\tid,\n\t\t\terror,\n\t\t\toperations,\n\t\t\tapply,\n\t\t\tat,\n\t\t\tget,\n\t\t\tpath,\n\t\t\texecutor,\n\t\t\tpayload\n\t\t});\n\t};\n}\n/**\n * Factories a process using the provided commands and an optional callback. Returns an executor used to run the process.\n *\n * @param commands The commands for the process\n * @param callback Callback called after the process is completed\n */\nexport function createProcess<T = any, P extends object = DefaultPayload>(\n\tid: string,\n\tcommands: Commands<T, P>,\n\tcallbacks?: ProcessCallback | ProcessCallback[]\n): Process<T, P> {\n\tcallbacks = Array.isArray(callbacks) ? callbacks : callbacks ? [callbacks] : [];\n\n\tconst callback = callbacks.length\n\t\t? callbacks.reduce((callback, nextCallback) => {\n\t\t\t\treturn combineCallbacks(nextCallback)(callback);\n\t\t  })\n\t\t: undefined;\n\n\tconst { before = undefined, after = undefined } = callback ? callback() : {};\n\n\tprocessMap.set(id, [id, commands, before, after]);\n\treturn (store: Store<T>, transformer?: Transformer<P>) =>\n\t\tprocessExecutor(id, commands, store, before, after, transformer);\n}\n\n/**\n * Creates a process factory that will create processes with the specified callback decorators applied.\n * @param callbacks array of process callback to be used by the returned factory.\n * @param initializers array of process initializers to be used by the returned factory.\n */\nexport function createProcessFactoryWith(callbacks: ProcessCallback[]) {\n\treturn <S, P extends object>(\n\t\tid: string,\n\t\tcommands: (Command<S, P>[] | Command<S, P>)[],\n\t\tcallback?: ProcessCallback<S>\n\t): Process<S, P> => {\n\t\treturn createProcess(id, commands, callback ? [...callbacks, callback] : callbacks);\n\t};\n}\n\n/**\n * Creates a `ProcessCallbackDecorator` from a `ProcessCallback`.\n * @param processCallback the process callback to convert to a decorator.\n */\nfunction combineCallbacks(processCallback: ProcessCallback): ProcessCallbackDecorator {\n\tconst { before, after } = processCallback();\n\treturn (previousCallback?: ProcessCallback) => {\n\t\tconst { before: previousBefore = undefined, after: previousAfter = undefined } = previousCallback\n\t\t\t? previousCallback()\n\t\t\t: {};\n\t\treturn () => ({\n\t\t\tafter(error: ProcessError | null, result: ProcessResult) {\n\t\t\t\tif (previousAfter) {\n\t\t\t\t\tpreviousAfter(error, result);\n\t\t\t\t}\n\n\t\t\t\tif (after) {\n\t\t\t\t\tafter(error, result);\n\t\t\t\t}\n\t\t\t},\n\t\t\tbefore(payload: DefaultPayload, store: Store<any>) {\n\t\t\t\tif (previousBefore) {\n\t\t\t\t\tpreviousBefore(payload, store);\n\t\t\t\t}\n\n\t\t\t\tif (before) {\n\t\t\t\t\tbefore(payload, store);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t};\n}\n\nexport function createCallbackDecorator(\n\tcallback: ProcessCallbackAfter\n): (callbacks?: ProcessCallback[]) => ProcessCallback[] {\n\tif (has('dojo-debug')) {\n\t\tconsole.warn(\n\t\t\t'Process using the the legacy middleware API. Please update to use the latest API, see https://github.com/dojo/framework/blob/master/docs/V5-Migration-Guide.md for details.'\n\t\t);\n\t}\n\tconst convertedCallback = () => ({\n\t\tafter: callback\n\t});\n\treturn (callbacks: ProcessCallback[] = []) => {\n\t\treturn [convertedCallback, ...callbacks];\n\t};\n}\n"]}