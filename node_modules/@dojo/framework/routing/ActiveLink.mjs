import * as tslib_1 from "tslib";
import WidgetBase from '../widget-core/WidgetBase';
import { w } from '../widget-core/d';
import diffProperty from '../widget-core/decorators/diffProperty';
import Link from './Link';
function paramsEqual(linkParams = {}, contextParams = {}) {
    return Object.keys(linkParams).every((key) => linkParams[key] === contextParams[key]);
}
export class ActiveLink extends WidgetBase {
    _renderLink(isActive = false) {
        let _a = this.properties, { activeClasses, classes = [] } = _a, props = tslib_1.__rest(_a, ["activeClasses", "classes"]);
        classes = Array.isArray(classes) ? classes : [classes];
        if (isActive) {
            classes = [...classes, ...activeClasses];
        }
        props = Object.assign({}, props, { classes });
        return w(Link, props, this.children);
    }
    _onOutletPropertyChange(previous, current) {
        const { to, routerKey = 'router' } = current;
        const item = this.registry.getInjector(routerKey);
        if (this._outletHandle) {
            this._outletHandle.destroy();
            this._outletHandle = undefined;
        }
        if (item) {
            const router = item.injector();
            this._outletHandle = router.on('outlet', ({ outlet }) => {
                if (outlet.id === to) {
                    this.invalidate();
                }
            });
        }
    }
    render() {
        const { to, routerKey = 'router', params } = this.properties;
        const item = this.registry.getInjector(routerKey);
        if (!item) {
            return this._renderLink();
        }
        const router = item.injector();
        const context = router.getOutlet(to);
        const isActive = context && paramsEqual(params, context.params);
        return this._renderLink(isActive);
    }
}
tslib_1.__decorate([
    diffProperty('to')
], ActiveLink.prototype, "_onOutletPropertyChange", null);
export default ActiveLink;
//# sourceMappingURL=ActiveLink.mjs.map