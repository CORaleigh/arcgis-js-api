(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "tslib", "../shim/global"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require("tslib");
    var global_1 = require("../shim/global");
    /**
     * A cache of results of feature tests
     */
    exports.testCache = {};
    /**
     * A cache of the un-resolved feature tests
     */
    exports.testFunctions = {};
    /* Grab the staticFeatures if there are available */
    var staticFeatures = (global_1.default.DojoHasEnvironment || {}).staticFeatures;
    /* Cleaning up the DojoHasEnviornment */
    if ('DojoHasEnvironment' in global_1.default) {
        delete global_1.default.DojoHasEnvironment;
    }
    /**
     * Custom type guard to narrow the `staticFeatures` to either a map or a function that
     * returns a map.
     *
     * @param value The value to guard for
     */
    function isStaticFeatureFunction(value) {
        return typeof value === 'function';
    }
    /**
     * The cache of asserted features that were available in the global scope when the
     * module loaded
     */
    var staticCache = staticFeatures
        ? isStaticFeatureFunction(staticFeatures)
            ? staticFeatures.apply(global_1.default)
            : staticFeatures
        : {}; /* Providing an empty cache, if none was in the environment

/**
 * AMD plugin function.
 *
 * Conditional loads modules based on a has feature test value.
 *
 * @param resourceId Gives the resolved module id to load.
 * @param require The loader require function with respect to the module that contained the plugin resource in its
 *                dependency list.
 * @param load Callback to loader that consumes result of plugin demand.
 */
    function load(resourceId, require, load, config) {
        resourceId ? require([resourceId], load) : load();
    }
    exports.load = load;
    /**
     * AMD plugin function.
     *
     * Resolves resourceId into a module id based on possibly-nested tenary expression that branches on has feature test
     * value(s).
     *
     * @param resourceId The id of the module
     * @param normalize Resolves a relative module id into an absolute module id
     */
    function normalize(resourceId, normalize) {
        var tokens = resourceId.match(/[\?:]|[^:\?]*/g) || [];
        var i = 0;
        function get(skip) {
            var term = tokens[i++];
            if (term === ':') {
                // empty string module name, resolves to null
                return null;
            }
            else {
                // postfixed with a ? means it is a feature to branch on, the term is the name of the feature
                if (tokens[i++] === '?') {
                    if (!skip && has(term)) {
                        // matched the feature, get the first value from the options
                        return get();
                    }
                    else {
                        // did not match, get the second value, passing over the first
                        get(true);
                        return get(skip);
                    }
                }
                // a module
                return term;
            }
        }
        var id = get();
        return id && normalize(id);
    }
    exports.normalize = normalize;
    /**
     * Check if a feature has already been registered
     *
     * @param feature the name of the feature
     */
    function exists(feature) {
        var normalizedFeature = feature.toLowerCase();
        return Boolean(normalizedFeature in staticCache || normalizedFeature in exports.testCache || exports.testFunctions[normalizedFeature]);
    }
    exports.exists = exists;
    /**
     * Register a new test for a named feature.
     *
     * @example
     * has.add('dom-addeventlistener', !!document.addEventListener);
     *
     * @example
     * has.add('touch-events', function () {
     *    return 'ontouchstart' in document
     * });
     *
     * @param feature the name of the feature
     * @param value the value reported of the feature, or a function that will be executed once on first test
     * @param overwrite if an existing value should be overwritten. Defaults to false.
     */
    function add(feature, value, overwrite) {
        if (overwrite === void 0) { overwrite = false; }
        var normalizedFeature = feature.toLowerCase();
        if (exists(normalizedFeature) && !overwrite && !(normalizedFeature in staticCache)) {
            throw new TypeError("Feature \"" + feature + "\" exists and overwrite not true.");
        }
        if (typeof value === 'function') {
            exports.testFunctions[normalizedFeature] = value;
        }
        else {
            exports.testCache[normalizedFeature] = value;
            delete exports.testFunctions[normalizedFeature];
        }
    }
    exports.add = add;
    /**
     * Return the current value of a named feature.
     *
     * @param feature The name of the feature to test.
     */
    function has(feature) {
        var result;
        var normalizedFeature = feature.toLowerCase();
        if (normalizedFeature in staticCache) {
            result = staticCache[normalizedFeature];
        }
        else if (exports.testFunctions[normalizedFeature]) {
            result = exports.testCache[normalizedFeature] = exports.testFunctions[normalizedFeature].call(null);
            delete exports.testFunctions[normalizedFeature];
        }
        else if (normalizedFeature in exports.testCache) {
            result = exports.testCache[normalizedFeature];
        }
        else {
            throw new TypeError("Attempt to detect unregistered has feature \"" + feature + "\"");
        }
        return result;
    }
    exports.default = has;
    /*
     * Out of the box feature tests
     */
    add('public-path', undefined);
    /* flag for dojo debug, default to false */
    add('dojo-debug', false);
    /* Detects if the environment is "browser like" */
    add('host-browser', typeof document !== 'undefined' && typeof location !== 'undefined');
    /* Detects if the environment appears to be NodeJS */
    add('host-node', function () {
        if (typeof process === 'object' && process.versions && process.versions.node) {
            return process.versions.node;
        }
    });
    add('fetch', 'fetch' in global_1.default && typeof global_1.default.fetch === 'function', true);
    add('es6-array', function () {
        return (['from', 'of'].every(function (key) { return key in global_1.default.Array; }) &&
            ['findIndex', 'find', 'copyWithin'].every(function (key) { return key in global_1.default.Array.prototype; }));
    }, true);
    add('es6-array-fill', function () {
        if ('fill' in global_1.default.Array.prototype) {
            /* Some versions of Safari do not properly implement this */
            return [1].fill(9, Number.POSITIVE_INFINITY)[0] === 1;
        }
        return false;
    }, true);
    add('es7-array', function () { return 'includes' in global_1.default.Array.prototype; }, true);
    /* Map */
    add('es6-map', function () {
        if (typeof global_1.default.Map === 'function') {
            /*
        IE11 and older versions of Safari are missing critical ES6 Map functionality
        We wrap this in a try/catch because sometimes the Map constructor exists, but does not
        take arguments (iOS 8.4)
         */
            try {
                var map = new global_1.default.Map([[0, 1]]);
                return (map.has(0) &&
                    typeof map.keys === 'function' &&
                    has('es6-symbol') &&
                    typeof map.values === 'function' &&
                    typeof map.entries === 'function');
            }
            catch (e) {
                /* istanbul ignore next: not testing on iOS at the moment */
                return false;
            }
        }
        return false;
    }, true);
    /* Math */
    add('es6-math', function () {
        return [
            'clz32',
            'sign',
            'log10',
            'log2',
            'log1p',
            'expm1',
            'cosh',
            'sinh',
            'tanh',
            'acosh',
            'asinh',
            'atanh',
            'trunc',
            'fround',
            'cbrt',
            'hypot'
        ].every(function (name) { return typeof global_1.default.Math[name] === 'function'; });
    }, true);
    add('es6-math-imul', function () {
        if ('imul' in global_1.default.Math) {
            /* Some versions of Safari on ios do not properly implement this */
            return Math.imul(0xffffffff, 5) === -5;
        }
        return false;
    }, true);
    /* Object */
    add('es6-object', function () {
        return (has('es6-symbol') &&
            ['assign', 'is', 'getOwnPropertySymbols', 'setPrototypeOf'].every(function (name) { return typeof global_1.default.Object[name] === 'function'; }));
    }, true);
    add('es2017-object', function () {
        return ['values', 'entries', 'getOwnPropertyDescriptors'].every(function (name) { return typeof global_1.default.Object[name] === 'function'; });
    }, true);
    /* Observable */
    add('es-observable', function () { return typeof global_1.default.Observable !== 'undefined'; }, true);
    /* Promise */
    add('es6-promise', function () { return typeof global_1.default.Promise !== 'undefined' && has('es6-symbol'); }, true);
    add('es2018-promise-finally', function () { return has('es6-promise') && typeof global_1.default.Promise.prototype.finally !== 'undefined'; }, true);
    /* Set */
    add('es6-set', function () {
        if (typeof global_1.default.Set === 'function') {
            /* IE11 and older versions of Safari are missing critical ES6 Set functionality */
            var set = new global_1.default.Set([1]);
            return set.has(1) && 'keys' in set && typeof set.keys === 'function' && has('es6-symbol');
        }
        return false;
    }, true);
    /* String */
    add('es6-string', function () {
        return ([
            /* static methods */
            'fromCodePoint'
        ].every(function (key) { return typeof global_1.default.String[key] === 'function'; }) &&
            [
                /* instance methods */
                'codePointAt',
                'normalize',
                'repeat',
                'startsWith',
                'endsWith',
                'includes'
            ].every(function (key) { return typeof global_1.default.String.prototype[key] === 'function'; }));
    }, true);
    add('es6-string-raw', function () {
        function getCallSite(callSite) {
            var substitutions = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                substitutions[_i - 1] = arguments[_i];
            }
            var result = tslib_1.__spread(callSite);
            result.raw = callSite.raw;
            return result;
        }
        if ('raw' in global_1.default.String) {
            var b = 1;
            var callSite = getCallSite(templateObject_1 || (templateObject_1 = tslib_1.__makeTemplateObject(["a\n", ""], ["a\\n", ""])), b);
            callSite.raw = ['a\\n'];
            var supportsTrunc = global_1.default.String.raw(callSite, 42) === 'a\\n';
            return supportsTrunc;
        }
        return false;
    }, true);
    add('es2017-string', function () {
        return ['padStart', 'padEnd'].every(function (key) { return typeof global_1.default.String.prototype[key] === 'function'; });
    }, true);
    /* Symbol */
    add('es6-symbol', function () { return typeof global_1.default.Symbol !== 'undefined' && typeof Symbol() === 'symbol'; }, true);
    /* WeakMap */
    add('es6-weakmap', function () {
        if (typeof global_1.default.WeakMap !== 'undefined') {
            /* IE11 and older versions of Safari are missing critical ES6 Map functionality */
            var key1 = {};
            var key2 = {};
            var map = new global_1.default.WeakMap([[key1, 1]]);
            Object.freeze(key1);
            return map.get(key1) === 1 && map.set(key2, 2) === map && has('es6-symbol');
        }
        return false;
    }, true);
    /* Miscellaneous features */
    add('microtasks', function () { return has('es6-promise') || has('host-node') || has('dom-mutationobserver'); }, true);
    add('postmessage', function () {
        // If window is undefined, and we have postMessage, it probably means we're in a web worker. Web workers have
        // post message but it doesn't work how we expect it to, so it's best just to pretend it doesn't exist.
        return typeof global_1.default.window !== 'undefined' && typeof global_1.default.postMessage === 'function';
    }, true);
    add('raf', function () { return typeof global_1.default.requestAnimationFrame === 'function'; }, true);
    add('setimmediate', function () { return typeof global_1.default.setImmediate !== 'undefined'; }, true);
    /* DOM Features */
    add('dom-mutationobserver', function () {
        if (has('host-browser') && Boolean(global_1.default.MutationObserver || global_1.default.WebKitMutationObserver)) {
            // IE11 has an unreliable MutationObserver implementation where setProperty() does not
            // generate a mutation event, observers can crash, and the queue does not drain
            // reliably. The following feature test was adapted from
            // https://gist.github.com/t10ko/4aceb8c71681fdb275e33efe5e576b14
            var example = document.createElement('div');
            /* tslint:disable-next-line:variable-name */
            var HostMutationObserver = global_1.default.MutationObserver || global_1.default.WebKitMutationObserver;
            var observer = new HostMutationObserver(function () { });
            observer.observe(example, { attributes: true });
            example.style.setProperty('display', 'block');
            return Boolean(observer.takeRecords().length);
        }
        return false;
    }, true);
    add('dom-webanimation', function () { return has('host-browser') && global_1.default.Animation !== undefined && global_1.default.KeyframeEffect !== undefined; }, true);
    add('abort-controller', function () { return typeof global_1.default.AbortController !== 'undefined'; });
    add('abort-signal', function () { return typeof global_1.default.AbortSignal !== 'undefined'; });
    add('dom-intersection-observer', function () { return has('host-browser') && global_1.default.IntersectionObserver !== undefined; }, true);
    add('dom-resize-observer', function () { return has('host-browser') && global_1.default.ResizeObserver !== undefined; }, true);
    add('dom-pointer-events', function () { return has('host-browser') && global_1.default.onpointerdown !== undefined; }, true);
    add('build-elide', false);
    var templateObject_1;
});
//# sourceMappingURL=has.js.map