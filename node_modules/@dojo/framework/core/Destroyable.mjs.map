{"version":3,"file":"Destroyable.mjs","sourceRoot":"","sources":["Destroyable.ts"],"names":[],"mappings":"AAAA,OAAO,OAAO,MAAM,iBAAiB,CAAC;AAatC;;GAEG;AACH;IACC,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;AAC/B,CAAC;AAED;;GAEG;AACH;IACC,MAAM,IAAI,KAAK,CAAC,+BAA+B,CAAC,CAAC;AAClD,CAAC;AAED,MAAM;IAML;;OAEG;IACH;QACC,IAAI,CAAC,OAAO,GAAG,EAAE,CAAC;IACnB,CAAC;IAED;;;;;;OAMG;IACH,GAAG,CAAC,MAAc;QACjB,MAAM,EAAE,OAAO,EAAE,QAAQ,EAAE,GAAG,IAAI,CAAC;QACnC,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;QACtB,MAAM,CAAC;YACN,OAAO;gBACN,QAAQ,CAAC,MAAM,CAAC,QAAQ,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC;gBAC1C,MAAM,CAAC,OAAO,EAAE,CAAC;YAClB,CAAC;SACD,CAAC;IACH,CAAC;IAED;;;;OAIG;IACH,OAAO;QACN,MAAM,CAAC,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,EAAE;YAC9B,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,MAAM,EAAE,EAAE;gBAC/B,MAAM,IAAI,MAAM,CAAC,OAAO,IAAI,MAAM,CAAC,OAAO,EAAE,CAAC;YAC9C,CAAC,CAAC,CAAC;YACH,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC;YACpB,IAAI,CAAC,GAAG,GAAG,SAAS,CAAC;YACrB,OAAO,CAAC,IAAI,CAAC,CAAC;QACf,CAAC,CAAC,CAAC;IACJ,CAAC;CACD;AAED,eAAe,WAAW,CAAC","sourcesContent":["import Promise from '../shim/Promise';\n\n/**\n * Used through the toolkit as a consistent API to manage how callers can \"cleanup\"\n * when doing a function.\n */\nexport interface Handle {\n\t/**\n\t * Perform the destruction/cleanup logic associated with this Handle\n\t */\n\tdestroy(): void;\n}\n\n/**\n * No op function used to replace a Destroyable instance's `destroy` method, once the instance has been destroyed\n */\nfunction noop(): Promise<boolean> {\n\treturn Promise.resolve(false);\n}\n\n/**\n * No op function used to replace a Destroyable instance's `own` method, once the instance has been destroyed\n */\nfunction destroyed(): never {\n\tthrow new Error('Call made to destroyed method');\n}\n\nexport class Destroyable {\n\t/**\n\t * The instance's handles\n\t */\n\tprivate handles: Handle[];\n\n\t/**\n\t * @constructor\n\t */\n\tconstructor() {\n\t\tthis.handles = [];\n\t}\n\n\t/**\n\t * Register handles for the instance that will be destroyed when `this.destroy` is called\n\t *\n\t * @param {Handle} handle The handle to add for the instance\n\t * @returns {Handle} A wrapper Handle. When the wrapper Handle's `destroy` method is invoked, the original handle is\n\t *                   removed from the instance, and its `destroy` method is invoked.\n\t */\n\town(handle: Handle): Handle {\n\t\tconst { handles: _handles } = this;\n\t\t_handles.push(handle);\n\t\treturn {\n\t\t\tdestroy() {\n\t\t\t\t_handles.splice(_handles.indexOf(handle));\n\t\t\t\thandle.destroy();\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Destroys all handlers registered for the instance\n\t *\n\t * @returns {Promise<any} A Promise that resolves once all handles have been destroyed\n\t */\n\tdestroy(): Promise<any> {\n\t\treturn new Promise((resolve) => {\n\t\t\tthis.handles.forEach((handle) => {\n\t\t\t\thandle && handle.destroy && handle.destroy();\n\t\t\t});\n\t\t\tthis.destroy = noop;\n\t\t\tthis.own = destroyed;\n\t\t\tresolve(true);\n\t\t});\n\t}\n}\n\nexport default Destroyable;\n"]}