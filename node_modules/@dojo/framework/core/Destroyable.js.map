{"version":3,"file":"Destroyable.js","sourceRoot":"","sources":["Destroyable.ts"],"names":[],"mappings":";;;;;;;;;;;IAAA,2CAAsC;IAatC;;OAEG;IACH;QACC,MAAM,CAAC,iBAAO,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;IAC/B,CAAC;IAED;;OAEG;IACH;QACC,MAAM,IAAI,KAAK,CAAC,+BAA+B,CAAC,CAAC;IAClD,CAAC;IAED;QAMC;;WAEG;QACH;YACC,IAAI,CAAC,OAAO,GAAG,EAAE,CAAC;QACnB,CAAC;QAED;;;;;;WAMG;QACH,yBAAG,GAAH,UAAI,MAAc;YACT,IAAA,uBAAiB,CAAU;YACnC,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;YACtB,MAAM,CAAC;gBACN,OAAO;oBACN,QAAQ,CAAC,MAAM,CAAC,QAAQ,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC;oBAC1C,MAAM,CAAC,OAAO,EAAE,CAAC;gBAClB,CAAC;aACD,CAAC;QACH,CAAC;QAED;;;;WAIG;QACH,6BAAO,GAAP;YAAA,iBASC;YARA,MAAM,CAAC,IAAI,iBAAO,CAAC,UAAC,OAAO;gBAC1B,KAAI,CAAC,OAAO,CAAC,OAAO,CAAC,UAAC,MAAM;oBAC3B,MAAM,IAAI,MAAM,CAAC,OAAO,IAAI,MAAM,CAAC,OAAO,EAAE,CAAC;gBAC9C,CAAC,CAAC,CAAC;gBACH,KAAI,CAAC,OAAO,GAAG,IAAI,CAAC;gBACpB,KAAI,CAAC,GAAG,GAAG,SAAS,CAAC;gBACrB,OAAO,CAAC,IAAI,CAAC,CAAC;YACf,CAAC,CAAC,CAAC;QACJ,CAAC;QACF,kBAAC;IAAD,CAAC,AA9CD,IA8CC;IA9CY,kCAAW;IAgDxB,kBAAe,WAAW,CAAC","sourcesContent":["import Promise from '../shim/Promise';\n\n/**\n * Used through the toolkit as a consistent API to manage how callers can \"cleanup\"\n * when doing a function.\n */\nexport interface Handle {\n\t/**\n\t * Perform the destruction/cleanup logic associated with this Handle\n\t */\n\tdestroy(): void;\n}\n\n/**\n * No op function used to replace a Destroyable instance's `destroy` method, once the instance has been destroyed\n */\nfunction noop(): Promise<boolean> {\n\treturn Promise.resolve(false);\n}\n\n/**\n * No op function used to replace a Destroyable instance's `own` method, once the instance has been destroyed\n */\nfunction destroyed(): never {\n\tthrow new Error('Call made to destroyed method');\n}\n\nexport class Destroyable {\n\t/**\n\t * The instance's handles\n\t */\n\tprivate handles: Handle[];\n\n\t/**\n\t * @constructor\n\t */\n\tconstructor() {\n\t\tthis.handles = [];\n\t}\n\n\t/**\n\t * Register handles for the instance that will be destroyed when `this.destroy` is called\n\t *\n\t * @param {Handle} handle The handle to add for the instance\n\t * @returns {Handle} A wrapper Handle. When the wrapper Handle's `destroy` method is invoked, the original handle is\n\t *                   removed from the instance, and its `destroy` method is invoked.\n\t */\n\town(handle: Handle): Handle {\n\t\tconst { handles: _handles } = this;\n\t\t_handles.push(handle);\n\t\treturn {\n\t\t\tdestroy() {\n\t\t\t\t_handles.splice(_handles.indexOf(handle));\n\t\t\t\thandle.destroy();\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Destroys all handlers registered for the instance\n\t *\n\t * @returns {Promise<any} A Promise that resolves once all handles have been destroyed\n\t */\n\tdestroy(): Promise<any> {\n\t\treturn new Promise((resolve) => {\n\t\t\tthis.handles.forEach((handle) => {\n\t\t\t\thandle && handle.destroy && handle.destroy();\n\t\t\t});\n\t\t\tthis.destroy = noop;\n\t\t\tthis.own = destroyed;\n\t\t\tresolve(true);\n\t\t});\n\t}\n}\n\nexport default Destroyable;\n"]}