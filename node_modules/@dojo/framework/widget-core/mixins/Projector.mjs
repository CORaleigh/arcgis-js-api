import * as tslib_1 from "tslib";
import WidgetBase from '../WidgetBase';
import { renderer } from './../vdom';
import { w } from '../d';
import { alwaysRender } from '../decorators/alwaysRender';
export var ProjectorAttachState;
(function (ProjectorAttachState) {
    ProjectorAttachState[ProjectorAttachState["Attached"] = 1] = "Attached";
    ProjectorAttachState[ProjectorAttachState["Detached"] = 2] = "Detached";
})(ProjectorAttachState || (ProjectorAttachState = {}));
let ProjectorWidget = class ProjectorWidget extends WidgetBase {
    render() {
        return this.properties.renderer();
    }
};
ProjectorWidget = tslib_1.__decorate([
    alwaysRender()
], ProjectorWidget);
export function ProjectorMixin(Base) {
    class Projector {
        constructor() {
            this._root = document.body;
            this._async = true;
            this._properties = {};
            this._widget = Base;
        }
        append(root = this._root) {
            this._root = root;
            this._renderResult = w(ProjectorWidget, {
                renderer: () => {
                    const _a = this._properties, { registry } = _a, props = tslib_1.__rest(_a, ["registry"]);
                    return w(this._widget, props, this._children);
                }
            });
            this._renderer = renderer(() => this._renderResult);
            this._renderer.mount({
                domNode: root,
                registry: this._properties.registry,
                sync: !this.async
            });
            this.projectorState = ProjectorAttachState.Attached;
            return {
                destroy() { }
            };
        }
        merge(root = document.body) {
            return this.append(root.parentNode || undefined);
        }
        set root(root) {
            if (this.projectorState === ProjectorAttachState.Attached) {
                throw new Error('Projector already attached, cannot change root element');
            }
            this._root = root;
        }
        get root() {
            return this._root;
        }
        get async() {
            return this._async;
        }
        set async(async) {
            if (this.projectorState === ProjectorAttachState.Attached) {
                throw new Error('Projector already attached, cannot change async mode');
            }
            this._async = async;
        }
        sandbox(doc = document) {
            if (this.projectorState === ProjectorAttachState.Attached) {
                throw new Error('Projector already attached, cannot create sandbox');
            }
            this._async = false;
            this.append(doc.createDocumentFragment());
        }
        setChildren(children) {
            this._children = children;
            if (this._renderer) {
                this._renderer.invalidate();
            }
        }
        setProperties(properties) {
            this._properties = properties;
            if (this._renderer) {
                this._renderer.invalidate();
            }
        }
        toHtml() {
            if (this.projectorState !== ProjectorAttachState.Attached) {
                throw new Error('Projector is not attached, cannot return an HTML string of projection.');
            }
            return this._root.childNodes[0].outerHTML;
        }
        destroy() { }
    }
    return Projector;
}
export default ProjectorMixin;
//# sourceMappingURL=Projector.mjs.map