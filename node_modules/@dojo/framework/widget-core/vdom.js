(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "tslib", "../shim/global", "../has/has", "../shim/WeakMap", "./animations/cssTransitions", "./d", "./Registry", "./WidgetBase"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require("tslib");
    var global_1 = require("../shim/global");
    var has_1 = require("../has/has");
    var WeakMap_1 = require("../shim/WeakMap");
    var cssTransitions_1 = require("./animations/cssTransitions");
    var d_1 = require("./d");
    var Registry_1 = require("./Registry");
    var WidgetBase_1 = require("./WidgetBase");
    var EMPTY_ARRAY = [];
    var nodeOperations = ['focus', 'blur', 'scrollIntoView', 'click'];
    var NAMESPACE_W3 = 'http://www.w3.org/';
    var NAMESPACE_SVG = NAMESPACE_W3 + '2000/svg';
    var NAMESPACE_XLINK = NAMESPACE_W3 + '1999/xlink';
    function isWNodeWrapper(child) {
        return child && d_1.isWNode(child.node);
    }
    function isVNodeWrapper(child) {
        return !!child && d_1.isVNode(child.node);
    }
    function isAttachApplication(value) {
        return !!value.type;
    }
    function updateAttributes(domNode, previousAttributes, attributes, namespace) {
        var attrNames = Object.keys(attributes);
        var attrCount = attrNames.length;
        for (var i = 0; i < attrCount; i++) {
            var attrName = attrNames[i];
            var attrValue = attributes[attrName];
            var previousAttrValue = previousAttributes[attrName];
            if (attrValue !== previousAttrValue) {
                updateAttribute(domNode, attrName, attrValue, namespace);
            }
        }
    }
    function buildPreviousProperties(domNode, current, next) {
        var _a = current.node, diffType = _a.diffType, properties = _a.properties, attributes = _a.attributes;
        if (!diffType || diffType === 'vdom') {
            return {
                properties: current.node.properties,
                attributes: current.node.attributes,
                events: current.node.events
            };
        }
        else if (diffType === 'none') {
            return { properties: {}, attributes: current.node.attributes ? {} : undefined, events: current.node.events };
        }
        var newProperties = {
            properties: {}
        };
        if (attributes) {
            newProperties.attributes = {};
            newProperties.events = current.node.events;
            Object.keys(properties).forEach(function (propName) {
                newProperties.properties[propName] = domNode[propName];
            });
            Object.keys(attributes).forEach(function (attrName) {
                newProperties.attributes[attrName] = domNode.getAttribute(attrName);
            });
            return newProperties;
        }
        newProperties.properties = Object.keys(properties).reduce(function (props, property) {
            props[property] = domNode.getAttribute(property) || domNode[property];
            return props;
        }, {});
        return newProperties;
    }
    function checkDistinguishable(wrappers, index, parentWNodeWrapper) {
        var wrapperToCheck = wrappers[index];
        if (isVNodeWrapper(wrapperToCheck) && !wrapperToCheck.node.tag) {
            return;
        }
        var key = wrapperToCheck.node.properties.key;
        var parentName = 'unknown';
        if (parentWNodeWrapper) {
            var widgetConstructor = parentWNodeWrapper.node.widgetConstructor;
            parentName = widgetConstructor.name || 'unknown';
        }
        if (key === undefined || key === null) {
            for (var i = 0; i < wrappers.length; i++) {
                if (i !== index) {
                    var wrapper = wrappers[i];
                    if (same(wrapper, wrapperToCheck)) {
                        var nodeIdentifier = void 0;
                        if (isWNodeWrapper(wrapper)) {
                            nodeIdentifier = wrapper.node.widgetConstructor.name || 'unknown';
                        }
                        else {
                            nodeIdentifier = wrapper.node.tag;
                        }
                        console.warn("A widget (" + parentName + ") has had a child added or removed, but they were not able to uniquely identified. It is recommended to provide a unique 'key' property when using the same widget or element (" + nodeIdentifier + ") multiple times as siblings");
                        break;
                    }
                }
            }
        }
    }
    function same(dnode1, dnode2) {
        if (isVNodeWrapper(dnode1) && isVNodeWrapper(dnode2)) {
            if (d_1.isDomVNode(dnode1.node) && d_1.isDomVNode(dnode2.node)) {
                if (dnode1.node.domNode !== dnode2.node.domNode) {
                    return false;
                }
            }
            if (dnode1.node.tag !== dnode2.node.tag) {
                return false;
            }
            if (dnode1.node.properties.key !== dnode2.node.properties.key) {
                return false;
            }
            return true;
        }
        else if (isWNodeWrapper(dnode1) && isWNodeWrapper(dnode2)) {
            if (dnode1.instance === undefined && typeof dnode2.node.widgetConstructor === 'string') {
                return false;
            }
            if (dnode1.node.widgetConstructor !== dnode2.node.widgetConstructor) {
                return false;
            }
            if (dnode1.node.properties.key !== dnode2.node.properties.key) {
                return false;
            }
            return true;
        }
        return false;
    }
    function findIndexOfChild(children, sameAs, start) {
        for (var i = start; i < children.length; i++) {
            if (same(children[i], sameAs)) {
                return i;
            }
        }
        return -1;
    }
    function createClassPropValue(classes) {
        if (classes === void 0) { classes = []; }
        classes = Array.isArray(classes) ? classes : [classes];
        return classes.join(' ').trim();
    }
    function updateAttribute(domNode, attrName, attrValue, namespace) {
        if (namespace === NAMESPACE_SVG && attrName === 'href' && attrValue) {
            domNode.setAttributeNS(NAMESPACE_XLINK, attrName, attrValue);
        }
        else if ((attrName === 'role' && attrValue === '') || attrValue === undefined) {
            domNode.removeAttribute(attrName);
        }
        else {
            domNode.setAttribute(attrName, attrValue);
        }
    }
    function runEnterAnimation(next, transitions) {
        var domNode = next.domNode, properties = next.node.properties, enterAnimation = next.node.properties.enterAnimation;
        if (enterAnimation) {
            if (typeof enterAnimation === 'function') {
                return enterAnimation(domNode, properties);
            }
            transitions.enter(domNode, properties, enterAnimation);
        }
    }
    function runExitAnimation(current, transitions) {
        var domNode = current.domNode, properties = current.node.properties, exitAnimation = current.node.properties.exitAnimation;
        var removeDomNode = function () {
            domNode && domNode.parentNode && domNode.parentNode.removeChild(domNode);
            current.domNode = undefined;
        };
        if (typeof exitAnimation === 'function') {
            return exitAnimation(domNode, removeDomNode, properties);
        }
        transitions.exit(domNode, properties, exitAnimation, removeDomNode);
    }
    function arrayFrom(arr) {
        return Array.prototype.slice.call(arr);
    }
    function wrapNodes(renderer) {
        return /** @class */ (function (_super) {
            tslib_1.__extends(class_1, _super);
            function class_1() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.isWNodeWrapper = true;
                return _this;
            }
            class_1.prototype.render = function () {
                var result = renderer();
                this.isWNodeWrapper = d_1.isWNode(result);
                return result;
            };
            return class_1;
        }(WidgetBase_1.WidgetBase));
    }
    function renderer(renderer) {
        var _mountOptions = {
            sync: false,
            merge: true,
            transition: cssTransitions_1.default,
            domNode: global_1.default.document.body,
            registry: null
        };
        var _invalidationQueue = [];
        var _processQueue = [];
        var _applicationQueue = [];
        var _eventMap = new WeakMap_1.WeakMap();
        var _instanceToWrapperMap = new WeakMap_1.WeakMap();
        var _parentWrapperMap = new WeakMap_1.WeakMap();
        var _wrapperSiblingMap = new WeakMap_1.WeakMap();
        var _insertBeforeMap = new WeakMap_1.WeakMap();
        var _renderScheduled;
        var _afterRenderCallbacks = [];
        var _deferredRenderCallbacks = [];
        var parentInvalidate;
        var _allMergedNodes = [];
        function nodeOperation(propName, propValue, previousValue, domNode) {
            var result = propValue && !previousValue;
            if (typeof propValue === 'function') {
                result = propValue();
            }
            if (result === true) {
                _afterRenderCallbacks.push(function () {
                    domNode[propName]();
                });
            }
        }
        function updateEvent(domNode, eventName, currentValue, bind, previousValue) {
            if (previousValue) {
                var previousEvent = _eventMap.get(previousValue);
                domNode.removeEventListener(eventName, previousEvent);
            }
            var callback = currentValue.bind(bind);
            if (eventName === 'input') {
                callback = function (evt) {
                    currentValue.call(this, evt);
                    evt.target['oninput-value'] = evt.target.value;
                }.bind(bind);
            }
            domNode.addEventListener(eventName, callback);
            _eventMap.set(currentValue, callback);
        }
        function removeOrphanedEvents(domNode, previousProperties, properties, onlyEvents) {
            if (onlyEvents === void 0) { onlyEvents = false; }
            Object.keys(previousProperties).forEach(function (propName) {
                var isEvent = propName.substr(0, 2) === 'on' || onlyEvents;
                var eventName = onlyEvents ? propName : propName.substr(2);
                if (isEvent && !properties[propName]) {
                    var eventCallback = _eventMap.get(previousProperties[propName]);
                    if (eventCallback) {
                        domNode.removeEventListener(eventName, eventCallback);
                    }
                }
            });
        }
        function renderedToWrapper(rendered, parent, currentParent) {
            var requiresInsertBefore = parent.requiresInsertBefore, hasPreviousSiblings = parent.hasPreviousSiblings, namespace = parent.namespace, depth = parent.depth;
            var wrappedRendered = [];
            var hasParentWNode = isWNodeWrapper(parent);
            var currentParentChildren = (isVNodeWrapper(currentParent) && currentParent.childrenWrappers) || [];
            var hasCurrentParentChildren = currentParentChildren.length > 0;
            var insertBefore = ((requiresInsertBefore || hasPreviousSiblings !== false) && hasParentWNode) ||
                (hasCurrentParentChildren && rendered.length > 1);
            var previousItem;
            for (var i = 0; i < rendered.length; i++) {
                var renderedItem = rendered[i];
                var wrapper = {
                    node: renderedItem,
                    depth: depth + 1,
                    order: i,
                    requiresInsertBefore: insertBefore,
                    hasParentWNode: hasParentWNode,
                    namespace: namespace
                };
                if (d_1.isVNode(renderedItem) && renderedItem.properties.exitAnimation) {
                    parent.hasAnimations = true;
                    var nextParent = _parentWrapperMap.get(parent);
                    while (nextParent) {
                        if (nextParent.hasAnimations) {
                            break;
                        }
                        nextParent.hasAnimations = true;
                        nextParent = _parentWrapperMap.get(nextParent);
                    }
                }
                _parentWrapperMap.set(wrapper, parent);
                if (previousItem) {
                    _wrapperSiblingMap.set(previousItem, wrapper);
                }
                wrappedRendered.push(wrapper);
                previousItem = wrapper;
            }
            return wrappedRendered;
        }
        function findParentWNodeWrapper(currentNode) {
            var parentWNodeWrapper;
            var parentWrapper = _parentWrapperMap.get(currentNode);
            while (!parentWNodeWrapper && parentWrapper) {
                if (!parentWNodeWrapper && isWNodeWrapper(parentWrapper)) {
                    parentWNodeWrapper = parentWrapper;
                }
                parentWrapper = _parentWrapperMap.get(parentWrapper);
            }
            return parentWNodeWrapper;
        }
        function findParentDomNode(currentNode) {
            var parentDomNode;
            var parentWrapper = _parentWrapperMap.get(currentNode);
            while (!parentDomNode && parentWrapper) {
                if (!parentDomNode && isVNodeWrapper(parentWrapper) && parentWrapper.domNode) {
                    parentDomNode = parentWrapper.domNode;
                }
                parentWrapper = _parentWrapperMap.get(parentWrapper);
            }
            return parentDomNode;
        }
        function runDeferredProperties(next) {
            if (next.node.deferredPropertiesCallback) {
                var properties_1 = next.node.properties;
                next.node.properties = tslib_1.__assign({}, next.node.deferredPropertiesCallback(true), next.node.originalProperties);
                _afterRenderCallbacks.push(function () {
                    processProperties(next, { properties: properties_1 });
                });
            }
        }
        function findInsertBefore(next) {
            var insertBefore = null;
            var searchNode = next;
            while (!insertBefore) {
                var nextSibling = _wrapperSiblingMap.get(searchNode);
                if (nextSibling) {
                    if (isVNodeWrapper(nextSibling)) {
                        if (nextSibling.domNode && nextSibling.domNode.parentNode) {
                            insertBefore = nextSibling.domNode;
                            break;
                        }
                        searchNode = nextSibling;
                        continue;
                    }
                    if (nextSibling.domNode && nextSibling.domNode.parentNode) {
                        insertBefore = nextSibling.domNode;
                        break;
                    }
                    searchNode = nextSibling;
                    continue;
                }
                searchNode = _parentWrapperMap.get(searchNode);
                if (!searchNode || isVNodeWrapper(searchNode)) {
                    break;
                }
            }
            return insertBefore;
        }
        function setValue(domNode, propValue, previousValue) {
            var domValue = domNode.value;
            var onInputValue = domNode['oninput-value'];
            var onSelectValue = domNode['select-value'];
            if (onSelectValue && domValue !== onSelectValue) {
                domNode.value = onSelectValue;
                if (domNode.value === onSelectValue) {
                    domNode['select-value'] = undefined;
                }
            }
            else if ((onInputValue && domValue === onInputValue) || propValue !== previousValue) {
                domNode.value = propValue;
                domNode['oninput-value'] = undefined;
            }
        }
        function setProperties(domNode, currentProperties, nextWrapper, includesEventsAndAttributes) {
            if (currentProperties === void 0) { currentProperties = {}; }
            if (includesEventsAndAttributes === void 0) { includesEventsAndAttributes = true; }
            var propNames = Object.keys(nextWrapper.node.properties);
            var propCount = propNames.length;
            if (propNames.indexOf('classes') === -1 && currentProperties.classes) {
                domNode.removeAttribute('class');
            }
            includesEventsAndAttributes && removeOrphanedEvents(domNode, currentProperties, nextWrapper.node.properties);
            for (var i = 0; i < propCount; i++) {
                var propName = propNames[i];
                var propValue = nextWrapper.node.properties[propName];
                var previousValue = currentProperties[propName];
                if (propName === 'classes') {
                    var previousClassString = createClassPropValue(previousValue);
                    var currentClassString = createClassPropValue(propValue);
                    if (previousClassString !== currentClassString) {
                        if (currentClassString) {
                            if (nextWrapper.merged) {
                                var domClasses = (domNode.getAttribute('class') || '').split(' ');
                                for (var i_1 = 0; i_1 < domClasses.length; i_1++) {
                                    if (currentClassString.indexOf(domClasses[i_1]) === -1) {
                                        currentClassString = domClasses[i_1] + " " + currentClassString;
                                    }
                                }
                            }
                            domNode.setAttribute('class', currentClassString);
                        }
                        else {
                            domNode.removeAttribute('class');
                        }
                    }
                }
                else if (nodeOperations.indexOf(propName) !== -1) {
                    nodeOperation(propName, propValue, previousValue, domNode);
                }
                else if (propName === 'styles') {
                    var styleNames = Object.keys(propValue);
                    var styleCount = styleNames.length;
                    for (var j = 0; j < styleCount; j++) {
                        var styleName = styleNames[j];
                        var newStyleValue = propValue[styleName];
                        var oldStyleValue = previousValue && previousValue[styleName];
                        if (newStyleValue === oldStyleValue) {
                            continue;
                        }
                        domNode.style[styleName] = newStyleValue || '';
                    }
                }
                else {
                    if (!propValue && typeof previousValue === 'string') {
                        propValue = '';
                    }
                    if (propName === 'value') {
                        if (domNode.tagName === 'SELECT') {
                            domNode['select-value'] = propValue;
                        }
                        setValue(domNode, propValue, previousValue);
                    }
                    else if (propName !== 'key' && propValue !== previousValue) {
                        var type = typeof propValue;
                        if (type === 'function' && propName.lastIndexOf('on', 0) === 0 && includesEventsAndAttributes) {
                            updateEvent(domNode, propName.substr(2), propValue, nextWrapper.node.bind, previousValue);
                        }
                        else if (type === 'string' && propName !== 'innerHTML' && includesEventsAndAttributes) {
                            updateAttribute(domNode, propName, propValue, nextWrapper.namespace);
                        }
                        else if (propName === 'scrollLeft' || propName === 'scrollTop') {
                            if (domNode[propName] !== propValue) {
                                domNode[propName] = propValue;
                            }
                        }
                        else {
                            domNode[propName] = propValue;
                        }
                    }
                }
            }
        }
        function runDeferredRenderCallbacks() {
            var sync = _mountOptions.sync;
            var callbacks = _deferredRenderCallbacks;
            _deferredRenderCallbacks = [];
            if (callbacks.length) {
                var run = function () {
                    var callback;
                    while ((callback = callbacks.shift())) {
                        callback();
                    }
                };
                if (sync) {
                    run();
                }
                else {
                    global_1.default.requestAnimationFrame(run);
                }
            }
        }
        function runAfterRenderCallbacks() {
            var sync = _mountOptions.sync;
            var callbacks = _afterRenderCallbacks;
            _afterRenderCallbacks = [];
            if (callbacks.length) {
                var run = function () {
                    var callback;
                    while ((callback = callbacks.shift())) {
                        callback();
                    }
                };
                if (sync) {
                    run();
                }
                else {
                    if (global_1.default.requestIdleCallback) {
                        global_1.default.requestIdleCallback(run);
                    }
                    else {
                        setTimeout(run);
                    }
                }
            }
        }
        function processProperties(next, previousProperties) {
            if (next.node.attributes && next.node.events) {
                updateAttributes(next.domNode, previousProperties.attributes || {}, next.node.attributes, next.namespace);
                setProperties(next.domNode, previousProperties.properties, next, false);
                var events_1 = next.node.events || {};
                if (previousProperties.events) {
                    removeOrphanedEvents(next.domNode, previousProperties.events || {}, next.node.events, true);
                }
                previousProperties.events = previousProperties.events || {};
                Object.keys(events_1).forEach(function (event) {
                    updateEvent(next.domNode, event, events_1[event], next.node.bind, previousProperties.events[event]);
                });
            }
            else {
                setProperties(next.domNode, previousProperties.properties, next);
            }
        }
        function mount(mountOptions) {
            if (mountOptions === void 0) { mountOptions = {}; }
            _mountOptions = tslib_1.__assign({}, _mountOptions, mountOptions);
            var domNode = _mountOptions.domNode;
            var renderResult = d_1.w(wrapNodes(renderer), {});
            var nextWrapper = {
                node: renderResult,
                order: 0,
                depth: 1
            };
            _parentWrapperMap.set(nextWrapper, { depth: 0, order: 0, domNode: domNode, node: d_1.v('fake') });
            _processQueue.push({
                current: [],
                next: [nextWrapper],
                meta: { mergeNodes: arrayFrom(domNode.childNodes) }
            });
            _runProcessQueue();
            var mergedNode;
            while ((mergedNode = _allMergedNodes.pop())) {
                mergedNode.parentNode && mergedNode.parentNode.removeChild(mergedNode);
            }
            _runDomInstructionQueue();
            _mountOptions.merge = false;
            _insertBeforeMap = undefined;
            _runCallbacks();
        }
        function invalidate() {
            parentInvalidate && parentInvalidate();
        }
        function _schedule() {
            var sync = _mountOptions.sync;
            if (sync) {
                _runInvalidationQueue();
            }
            else if (!_renderScheduled) {
                _renderScheduled = global_1.default.requestAnimationFrame(function () {
                    _runInvalidationQueue();
                });
            }
        }
        function _runInvalidationQueue() {
            _renderScheduled = undefined;
            var invalidationQueue = tslib_1.__spread(_invalidationQueue);
            var previouslyRendered = [];
            _invalidationQueue = [];
            invalidationQueue.sort(function (a, b) {
                var result = b.depth - a.depth;
                if (result === 0) {
                    result = b.order - a.order;
                }
                return result;
            });
            var item;
            while ((item = invalidationQueue.pop())) {
                var instance = item.instance;
                if (previouslyRendered.indexOf(instance) === -1 && _instanceToWrapperMap.has(instance)) {
                    previouslyRendered.push(instance);
                    var current = _instanceToWrapperMap.get(instance);
                    var instanceData = WidgetBase_1.widgetInstanceMap.get(instance);
                    var parent_1 = _parentWrapperMap.get(current);
                    var sibling = _wrapperSiblingMap.get(current);
                    var constructor = instance.constructor, children = instance.children;
                    var next = {
                        node: {
                            type: d_1.WNODE,
                            widgetConstructor: constructor,
                            properties: instanceData.inputProperties,
                            children: children,
                            bind: current.node.bind
                        },
                        instance: instance,
                        depth: current.depth,
                        order: current.order
                    };
                    parent_1 && _parentWrapperMap.set(next, parent_1);
                    sibling && _wrapperSiblingMap.set(next, sibling);
                    var item_1 = _updateWidget({ current: current, next: next }).item;
                    if (item_1) {
                        _processQueue.push(item_1);
                        instance && _instanceToWrapperMap.set(instance, next);
                        _runProcessQueue();
                    }
                }
            }
            _runDomInstructionQueue();
            _runCallbacks();
        }
        function _runProcessQueue() {
            var item;
            while ((item = _processQueue.pop())) {
                if (isAttachApplication(item)) {
                    _applicationQueue.push(item);
                }
                else {
                    var current = item.current, next = item.next, meta = item.meta;
                    _process(current || EMPTY_ARRAY, next || EMPTY_ARRAY, meta);
                }
            }
        }
        function _runDomInstructionQueue() {
            _applicationQueue.reverse();
            var item;
            while ((item = _applicationQueue.pop())) {
                if (item.type === 'create') {
                    var parentDomNode = item.parentDomNode, next = item.next, _a = item.next, domNode = _a.domNode, merged = _a.merged, requiresInsertBefore = _a.requiresInsertBefore, properties = _a.node.properties;
                    processProperties(next, { properties: {} });
                    runDeferredProperties(next);
                    if (!merged) {
                        var insertBefore = void 0;
                        if (requiresInsertBefore) {
                            insertBefore = findInsertBefore(next);
                        }
                        else if (_insertBeforeMap) {
                            insertBefore = _insertBeforeMap.get(next);
                        }
                        parentDomNode.insertBefore(domNode, insertBefore);
                        if (d_1.isDomVNode(next.node) && next.node.onAttach) {
                            next.node.onAttach();
                        }
                    }
                    if (domNode.tagName === 'OPTION' && domNode.parentElement) {
                        setValue(domNode.parentElement);
                    }
                    runEnterAnimation(next, _mountOptions.transition);
                    var instanceData = WidgetBase_1.widgetInstanceMap.get(next.node.bind);
                    if (properties.key != null && instanceData) {
                        instanceData.nodeHandler.add(domNode, "" + properties.key);
                    }
                    item.next.inserted = true;
                }
                else if (item.type === 'update') {
                    var next = item.next, _b = item.next, domNode = _b.domNode, node = _b.node, current = item.current;
                    var parent_2 = _parentWrapperMap.get(next);
                    if (parent_2 && isWNodeWrapper(parent_2) && parent_2.instance) {
                        var instanceData_1 = WidgetBase_1.widgetInstanceMap.get(parent_2.instance);
                        instanceData_1 && instanceData_1.nodeHandler.addRoot();
                    }
                    var previousProperties = buildPreviousProperties(domNode, current, next);
                    var instanceData = WidgetBase_1.widgetInstanceMap.get(next.node.bind);
                    processProperties(next, previousProperties);
                    runDeferredProperties(next);
                    if (instanceData && node.properties.key != null) {
                        instanceData.nodeHandler.add(next.domNode, "" + node.properties.key);
                    }
                }
                else if (item.type === 'delete') {
                    var current = item.current;
                    if (current.node.properties.exitAnimation) {
                        runExitAnimation(current, _mountOptions.transition);
                    }
                    else {
                        current.domNode.parentNode.removeChild(current.domNode);
                        current.domNode = undefined;
                    }
                }
                else if (item.type === 'attach') {
                    var instance = item.instance, attached = item.attached;
                    var instanceData = WidgetBase_1.widgetInstanceMap.get(instance);
                    instanceData.nodeHandler.addRoot();
                    attached && instanceData.onAttach();
                }
                else if (item.type === 'detach') {
                    if (item.current.instance) {
                        var instanceData = WidgetBase_1.widgetInstanceMap.get(item.current.instance);
                        instanceData && instanceData.onDetach();
                    }
                    item.current.domNode = undefined;
                    item.current.node.bind = undefined;
                    item.current.instance = undefined;
                }
            }
        }
        function _runCallbacks() {
            runAfterRenderCallbacks();
            runDeferredRenderCallbacks();
        }
        function _processMergeNodes(next, mergeNodes) {
            var merge = _mountOptions.merge;
            if (merge && mergeNodes.length) {
                if (isVNodeWrapper(next)) {
                    var tag = next.node.tag;
                    for (var i = 0; i < mergeNodes.length; i++) {
                        var domElement = mergeNodes[i];
                        if (tag.toUpperCase() === (domElement.tagName || '')) {
                            var mergeNodeIndex = _allMergedNodes.indexOf(domElement);
                            if (mergeNodeIndex !== -1) {
                                _allMergedNodes.splice(mergeNodeIndex, 1);
                            }
                            mergeNodes.splice(i, 1);
                            next.domNode = domElement;
                            break;
                        }
                    }
                }
                else {
                    next.mergeNodes = mergeNodes;
                }
            }
        }
        function registerDistinguishableCallback(childNodes, index) {
            _afterRenderCallbacks.push(function () {
                var parentWNodeWrapper = findParentWNodeWrapper(childNodes[index]);
                checkDistinguishable(childNodes, index, parentWNodeWrapper);
            });
        }
        function _process(current, next, meta) {
            if (meta === void 0) { meta = {}; }
            var _a = meta.mergeNodes, mergeNodes = _a === void 0 ? [] : _a, _b = meta.oldIndex, oldIndex = _b === void 0 ? 0 : _b, _c = meta.newIndex, newIndex = _c === void 0 ? 0 : _c;
            var currentLength = current.length;
            var nextLength = next.length;
            var hasPreviousSiblings = currentLength > 1 || (currentLength > 0 && currentLength < nextLength);
            var instructions = [];
            if (newIndex < nextLength) {
                var currentWrapper = oldIndex < currentLength ? current[oldIndex] : undefined;
                var nextWrapper = next[newIndex];
                nextWrapper.hasPreviousSiblings = hasPreviousSiblings;
                _processMergeNodes(nextWrapper, mergeNodes);
                if (currentWrapper && same(currentWrapper, nextWrapper)) {
                    oldIndex++;
                    newIndex++;
                    if (isVNodeWrapper(currentWrapper) && isVNodeWrapper(nextWrapper)) {
                        nextWrapper.inserted = currentWrapper.inserted;
                    }
                    instructions.push({ current: currentWrapper, next: nextWrapper });
                }
                else if (!currentWrapper || findIndexOfChild(current, nextWrapper, oldIndex + 1) === -1) {
                    has_1.default('dojo-debug') && current.length && registerDistinguishableCallback(next, newIndex);
                    instructions.push({ current: undefined, next: nextWrapper });
                    newIndex++;
                }
                else if (findIndexOfChild(next, currentWrapper, newIndex + 1) === -1) {
                    has_1.default('dojo-debug') && registerDistinguishableCallback(current, oldIndex);
                    instructions.push({ current: currentWrapper, next: undefined });
                    oldIndex++;
                }
                else {
                    has_1.default('dojo-debug') && registerDistinguishableCallback(next, newIndex);
                    has_1.default('dojo-debug') && registerDistinguishableCallback(current, oldIndex);
                    instructions.push({ current: currentWrapper, next: undefined });
                    instructions.push({ current: undefined, next: nextWrapper });
                    oldIndex++;
                    newIndex++;
                }
            }
            if (newIndex < nextLength) {
                _processQueue.push({ current: current, next: next, meta: { mergeNodes: mergeNodes, oldIndex: oldIndex, newIndex: newIndex } });
            }
            if (currentLength > oldIndex && newIndex >= nextLength) {
                for (var i = oldIndex; i < currentLength; i++) {
                    has_1.default('dojo-debug') && registerDistinguishableCallback(current, i);
                    instructions.push({ current: current[i], next: undefined });
                }
            }
            for (var i = 0; i < instructions.length; i++) {
                var _d = _processOne(instructions[i]), item = _d.item, dom = _d.dom, widget = _d.widget;
                widget && _processQueue.push(widget);
                item && _processQueue.push(item);
                dom && _applicationQueue.push(dom);
            }
        }
        function _processOne(_a) {
            var current = _a.current, next = _a.next;
            if (current !== next) {
                if (!current && next) {
                    if (isVNodeWrapper(next)) {
                        return _createDom({ next: next });
                    }
                    else {
                        return _createWidget({ next: next });
                    }
                }
                else if (current && next) {
                    if (isVNodeWrapper(current) && isVNodeWrapper(next)) {
                        return _updateDom({ current: current, next: next });
                    }
                    else if (isWNodeWrapper(current) && isWNodeWrapper(next)) {
                        return _updateWidget({ current: current, next: next });
                    }
                }
                else if (current && !next) {
                    if (isVNodeWrapper(current)) {
                        return _removeDom({ current: current });
                    }
                    else if (isWNodeWrapper(current)) {
                        return _removeWidget({ current: current });
                    }
                }
            }
            return {};
        }
        function _createWidget(_a) {
            var next = _a.next;
            var widgetConstructor = next.node.widgetConstructor;
            var registry = _mountOptions.registry;
            if (!Registry_1.isWidgetBaseConstructor(widgetConstructor)) {
                return {};
            }
            var instance = new widgetConstructor();
            if (registry) {
                instance.registry.base = registry;
            }
            var instanceData = WidgetBase_1.widgetInstanceMap.get(instance);
            instanceData.invalidate = function () {
                instanceData.dirty = true;
                if (!instanceData.rendering && _instanceToWrapperMap.has(instance)) {
                    _invalidationQueue.push({ instance: instance, depth: next.depth, order: next.order });
                    _schedule();
                }
            };
            instanceData.rendering = true;
            instance.__setProperties__(next.node.properties, next.node.bind);
            instance.__setChildren__(next.node.children);
            next.instance = instance;
            var rendered = instance.__render__();
            instanceData.rendering = false;
            if (rendered) {
                rendered = Array.isArray(rendered) ? rendered : [rendered];
                next.childrenWrappers = renderedToWrapper(rendered, next, null);
            }
            if (next.instance) {
                _instanceToWrapperMap.set(next.instance, next);
                if (!parentInvalidate && !next.instance.isWNodeWrapper) {
                    parentInvalidate = next.instance.invalidate.bind(next.instance);
                }
            }
            return {
                item: { next: next.childrenWrappers, meta: { mergeNodes: next.mergeNodes } },
                widget: { type: 'attach', instance: instance, attached: true }
            };
        }
        function _updateWidget(_a) {
            var current = _a.current, next = _a.next;
            current = (current.instance && _instanceToWrapperMap.get(current.instance)) || current;
            var instance = current.instance, domNode = current.domNode, hasAnimations = current.hasAnimations;
            if (!instance) {
                return [];
            }
            var instanceData = WidgetBase_1.widgetInstanceMap.get(instance);
            next.instance = instance;
            next.domNode = domNode;
            next.hasAnimations = hasAnimations;
            instanceData.rendering = true;
            instance.__setProperties__(next.node.properties, next.node.bind);
            instance.__setChildren__(next.node.children);
            _instanceToWrapperMap.set(next.instance, next);
            if (instanceData.dirty) {
                var rendered = instance.__render__();
                instanceData.rendering = false;
                if (rendered) {
                    rendered = Array.isArray(rendered) ? rendered : [rendered];
                    next.childrenWrappers = renderedToWrapper(rendered, next, current);
                }
                return {
                    item: { current: current.childrenWrappers, next: next.childrenWrappers, meta: {} },
                    widget: { type: 'attach', instance: instance, attached: false }
                };
            }
            instanceData.rendering = false;
            next.childrenWrappers = current.childrenWrappers;
            return {
                widget: { type: 'attach', instance: instance, attached: false }
            };
        }
        function _removeWidget(_a) {
            var current = _a.current;
            current = current.instance ? _instanceToWrapperMap.get(current.instance) : current;
            _wrapperSiblingMap.delete(current);
            _parentWrapperMap.delete(current);
            _instanceToWrapperMap.delete(current.instance);
            return {
                item: { current: current.childrenWrappers, meta: {} },
                widget: { type: 'detach', current: current }
            };
        }
        function _createDom(_a) {
            var next = _a.next;
            var mergeNodes = [];
            var parentDomNode = findParentDomNode(next);
            if (!next.domNode) {
                if (next.node.domNode) {
                    next.domNode = next.node.domNode;
                }
                else {
                    if (next.node.tag === 'svg') {
                        next.namespace = NAMESPACE_SVG;
                    }
                    if (next.node.tag) {
                        if (next.namespace) {
                            next.domNode = global_1.default.document.createElementNS(next.namespace, next.node.tag);
                        }
                        else {
                            next.domNode = global_1.default.document.createElement(next.node.tag);
                        }
                    }
                    else if (next.node.text != null) {
                        next.domNode = global_1.default.document.createTextNode(next.node.text);
                    }
                }
                if (_insertBeforeMap && _allMergedNodes.length) {
                    if (parentDomNode === _allMergedNodes[0].parentNode) {
                        _insertBeforeMap.set(next, _allMergedNodes[0]);
                    }
                }
            }
            else {
                if (_mountOptions.merge) {
                    mergeNodes = arrayFrom(next.domNode.childNodes);
                    _allMergedNodes = tslib_1.__spread(_allMergedNodes, mergeNodes);
                }
                next.merged = true;
            }
            if (next.domNode) {
                if (next.node.children) {
                    next.childrenWrappers = renderedToWrapper(next.node.children, next, null);
                }
            }
            var parentWNodeWrapper = findParentWNodeWrapper(next);
            if (parentWNodeWrapper && !parentWNodeWrapper.domNode) {
                parentWNodeWrapper.domNode = next.domNode;
            }
            var dom = {
                next: next,
                parentDomNode: parentDomNode,
                type: 'create'
            };
            if (next.childrenWrappers) {
                return {
                    item: { current: [], next: next.childrenWrappers, meta: { mergeNodes: mergeNodes } },
                    dom: dom
                };
            }
            return { dom: dom };
        }
        function _updateDom(_a) {
            var current = _a.current, next = _a.next;
            var parentDomNode = findParentDomNode(current);
            next.domNode = current.domNode;
            next.namespace = current.namespace;
            if (next.node.text && next.node.text !== current.node.text) {
                var updatedTextNode = parentDomNode.ownerDocument.createTextNode(next.node.text);
                parentDomNode.replaceChild(updatedTextNode, next.domNode);
                next.domNode = updatedTextNode;
            }
            else if (next.node.children) {
                var children = renderedToWrapper(next.node.children, next, current);
                next.childrenWrappers = children;
            }
            return {
                item: { current: current.childrenWrappers, next: next.childrenWrappers, meta: {} },
                dom: { type: 'update', next: next, current: current }
            };
        }
        function _removeDom(_a) {
            var current = _a.current;
            _wrapperSiblingMap.delete(current);
            _parentWrapperMap.delete(current);
            current.node.bind = undefined;
            if (current.hasAnimations) {
                return {
                    item: { current: current.childrenWrappers, meta: {} },
                    dom: { type: 'delete', current: current }
                };
            }
            if (current.childrenWrappers) {
                _afterRenderCallbacks.push(function () {
                    var wrappers = current.childrenWrappers || [];
                    var wrapper;
                    while ((wrapper = wrappers.pop())) {
                        if (wrapper.childrenWrappers) {
                            wrappers.push.apply(wrappers, tslib_1.__spread(wrapper.childrenWrappers));
                            wrapper.childrenWrappers = undefined;
                        }
                        if (isWNodeWrapper(wrapper)) {
                            if (wrapper.instance) {
                                _instanceToWrapperMap.delete(wrapper.instance);
                                var instanceData = WidgetBase_1.widgetInstanceMap.get(wrapper.instance);
                                instanceData && instanceData.onDetach();
                            }
                            wrapper.instance = undefined;
                        }
                        _wrapperSiblingMap.delete(wrapper);
                        _parentWrapperMap.delete(wrapper);
                        wrapper.domNode = undefined;
                        wrapper.node.bind = undefined;
                    }
                });
            }
            return {
                dom: { type: 'delete', current: current }
            };
        }
        return {
            mount: mount,
            invalidate: invalidate
        };
    }
    exports.renderer = renderer;
    exports.default = renderer;
});
//# sourceMappingURL=vdom.js.map