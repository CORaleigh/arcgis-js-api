{"version":3,"file":"d.mjs","sourceRoot":"","sources":["d.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n\tConstructor,\n\tDefaultWidgetBaseInterface,\n\tDeferredVirtualProperties,\n\tDNode,\n\tVNode,\n\tRegistryLabel,\n\tVNodeProperties,\n\tWidgetBaseInterface,\n\tWNode,\n\tDomOptions,\n\tRenderResult,\n\tDomVNode,\n\tLazyWidget,\n\tLazyDefine\n} from './interfaces';\n\n/**\n * The identifier for a WNode type\n */\nexport const WNODE = '__WNODE_TYPE';\n\n/**\n * The identifier for a VNode type\n */\nexport const VNODE = '__VNODE_TYPE';\n\n/**\n * The identifier for a VNode type created using dom()\n */\nexport const DOMVNODE = '__DOMVNODE_TYPE';\n\n/**\n * Helper function that returns true if the `DNode` is a `WNode` using the `type` property\n */\nexport function isWNode<W extends WidgetBaseInterface = DefaultWidgetBaseInterface>(\n\tchild: DNode<W> | any\n): child is WNode<W> {\n\treturn Boolean(child && typeof child !== 'string' && child.type === WNODE);\n}\n\n/**\n * Helper function that returns true if the `DNode` is a `VNode` using the `type` property\n */\nexport function isVNode(child: DNode): child is VNode {\n\treturn Boolean(child && typeof child !== 'string' && (child.type === VNODE || child.type === DOMVNODE));\n}\n\n/**\n * Helper function that returns true if the `DNode` is a `VNode` created with `dom()` using the `type` property\n */\nexport function isDomVNode(child: DNode): child is DomVNode {\n\treturn Boolean(child && typeof child !== 'string' && child.type === DOMVNODE);\n}\n\nexport function isElementNode(value: any): value is Element {\n\treturn !!value.tagName;\n}\n\n/**\n * Interface for the decorate modifier\n */\nexport interface Modifier<T extends DNode> {\n\t(dNode: T, breaker: () => void): void;\n}\n\n/**\n * The predicate function for decorate\n */\nexport interface Predicate<T extends DNode> {\n\t(dNode: DNode): dNode is T;\n}\n\n/**\n * Decorator options\n */\nexport interface DecorateOptions<T extends DNode> {\n\tmodifier: Modifier<T>;\n\tpredicate?: Predicate<T>;\n\tshallow?: boolean;\n}\n\n/**\n * Generic decorate function for DNodes. The nodes are modified in place based on the provided predicate\n * and modifier functions.\n *\n * The children of each node are flattened and added to the array for decoration.\n *\n * If no predicate is supplied then the modifier will be executed on all nodes. A `breaker` function is passed to the\n * modifier which will drain the nodes array and exit the decoration.\n *\n * When the `shallow` options is set to `true` the only the top node or nodes will be decorated (only supported using\n * `DecorateOptions`).\n */\nexport function decorate<T extends DNode>(dNodes: DNode, options: DecorateOptions<T>): DNode;\nexport function decorate<T extends DNode>(dNodes: DNode[], options: DecorateOptions<T>): DNode[];\nexport function decorate<T extends DNode>(dNodes: DNode | DNode[], options: DecorateOptions<T>): DNode | DNode[];\nexport function decorate<T extends DNode>(dNodes: DNode, modifier: Modifier<T>, predicate: Predicate<T>): DNode;\nexport function decorate<T extends DNode>(dNodes: DNode[], modifier: Modifier<T>, predicate: Predicate<T>): DNode[];\nexport function decorate<T extends DNode>(\n\tdNodes: RenderResult,\n\tmodifier: Modifier<T>,\n\tpredicate: Predicate<T>\n): RenderResult;\nexport function decorate(dNodes: DNode, modifier: Modifier<DNode>): DNode;\nexport function decorate(dNodes: DNode[], modifier: Modifier<DNode>): DNode[];\nexport function decorate(dNodes: RenderResult, modifier: Modifier<DNode>): RenderResult;\nexport function decorate(\n\tdNodes: DNode | DNode[],\n\toptionsOrModifier: Modifier<DNode> | DecorateOptions<DNode>,\n\tpredicate?: Predicate<DNode>\n): DNode | DNode[] {\n\tlet shallow = false;\n\tlet modifier;\n\tif (typeof optionsOrModifier === 'function') {\n\t\tmodifier = optionsOrModifier;\n\t} else {\n\t\tmodifier = optionsOrModifier.modifier;\n\t\tpredicate = optionsOrModifier.predicate;\n\t\tshallow = optionsOrModifier.shallow || false;\n\t}\n\n\tlet nodes = Array.isArray(dNodes) ? [...dNodes] : [dNodes];\n\tfunction breaker() {\n\t\tnodes = [];\n\t}\n\twhile (nodes.length) {\n\t\tconst node = nodes.shift();\n\t\tif (node) {\n\t\t\tif (!shallow && (isWNode(node) || isVNode(node)) && node.children) {\n\t\t\t\tnodes = [...nodes, ...node.children];\n\t\t\t}\n\t\t\tif (!predicate || predicate(node)) {\n\t\t\t\tmodifier(node, breaker);\n\t\t\t}\n\t\t}\n\t}\n\treturn dNodes;\n}\n\n/**\n * Wrapper function for calls to create a widget.\n */\nexport function w<W extends WidgetBaseInterface>(\n\tnode: WNode<W>,\n\tproperties: Partial<W['properties']>,\n\tchildren?: W['children']\n): WNode<W>;\nexport function w<W extends WidgetBaseInterface>(\n\twidgetConstructor: Constructor<W> | RegistryLabel | LazyWidget<W> | LazyDefine<W>,\n\tproperties: W['properties'],\n\tchildren?: W['children']\n): WNode<W>;\nexport function w<W extends WidgetBaseInterface>(\n\twidgetConstructorOrNode: Constructor<W> | RegistryLabel | WNode<W> | LazyWidget<W> | LazyDefine<W>,\n\tproperties: W['properties'],\n\tchildren?: W['children']\n): WNode<W> {\n\tif (isWNode(widgetConstructorOrNode)) {\n\t\tproperties = { ...(widgetConstructorOrNode.properties as any), ...(properties as any) };\n\t\tchildren = children ? children : widgetConstructorOrNode.children;\n\t\twidgetConstructorOrNode = widgetConstructorOrNode.widgetConstructor;\n\t}\n\n\treturn {\n\t\tchildren: children || [],\n\t\twidgetConstructor: widgetConstructorOrNode,\n\t\tproperties,\n\t\ttype: WNODE\n\t};\n}\n\n/**\n * Wrapper function for calls to create VNodes.\n */\nexport function v(node: VNode, properties: VNodeProperties, children: undefined | DNode[]): VNode;\nexport function v(node: VNode, properties: VNodeProperties): VNode;\nexport function v(tag: string, children: undefined | DNode[]): VNode;\nexport function v(tag: string, properties: DeferredVirtualProperties | VNodeProperties, children?: DNode[]): VNode;\nexport function v(tag: string): VNode;\nexport function v(\n\ttag: string | VNode,\n\tpropertiesOrChildren: VNodeProperties | DeferredVirtualProperties | DNode[] = {},\n\tchildren: undefined | DNode[] = undefined\n): VNode {\n\tlet properties: VNodeProperties | DeferredVirtualProperties = propertiesOrChildren;\n\tlet deferredPropertiesCallback;\n\n\tif (Array.isArray(propertiesOrChildren)) {\n\t\tchildren = propertiesOrChildren;\n\t\tproperties = {};\n\t}\n\n\tif (typeof properties === 'function') {\n\t\tdeferredPropertiesCallback = properties;\n\t\tproperties = {};\n\t}\n\n\tif (isVNode(tag)) {\n\t\tlet { classes = [], styles = {}, ...newProperties } = properties;\n\t\tlet { classes: nodeClasses = [], styles: nodeStyles = {}, ...nodeProperties } = tag.properties;\n\t\tnodeClasses = Array.isArray(nodeClasses) ? nodeClasses : [nodeClasses];\n\t\tclasses = Array.isArray(classes) ? classes : [classes];\n\t\tstyles = { ...nodeStyles, ...styles };\n\t\tproperties = { ...nodeProperties, ...newProperties, classes: [...nodeClasses, ...classes], styles };\n\t\tchildren = children ? children : tag.children;\n\t\ttag = tag.tag;\n\t}\n\n\treturn {\n\t\ttag,\n\t\tdeferredPropertiesCallback,\n\t\toriginalProperties: {},\n\t\tchildren,\n\t\tproperties,\n\t\ttype: VNODE\n\t};\n}\n\n/**\n * Create a VNode for an existing DOM Node.\n */\nexport function dom(\n\t{ node, attrs = {}, props = {}, on = {}, diffType = 'none', onAttach }: DomOptions,\n\tchildren?: DNode[]\n): DomVNode {\n\treturn {\n\t\ttag: isElementNode(node) ? node.tagName.toLowerCase() : '',\n\t\tproperties: props,\n\t\tattributes: attrs,\n\t\tevents: on,\n\t\tchildren,\n\t\ttype: DOMVNODE,\n\t\tdomNode: node,\n\t\ttext: isElementNode(node) ? undefined : node.data,\n\t\tdiffType,\n\t\tonAttach\n\t};\n}\n"]}