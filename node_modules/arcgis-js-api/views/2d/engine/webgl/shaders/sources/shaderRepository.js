// COPYRIGHT Â© 2018 Esri
//
// All rights reserved under the copyright laws of the United States
// and applicable international laws, treaties, and conventions.
//
// This material is licensed for use under the Esri Master License
// Agreement (MLA), and is bound by the terms of that agreement.
// You may redistribute and use this code without modification,
// provided you adhere to the terms of the MLA and include this
// copyright notice.
//
// See use restrictions at http://www.esri.com/legal/pdfs/mla_e204_e300/english
//
// For additional information, contact:
// Environmental Systems Research Institute, Inc.
// Attn: Contracts and Legal Services Department
// 380 New York Street
// Redlands, California, USA 92373
// USA
//
// email: contracts@esri.com
//
// See http://js.arcgis.com/4.11/esri/copyright.txt for details.

define(["require","exports"],function(e,n){return{background:{"background.frag":"uniform lowp vec4 u_color;\nvoid main() {\n  gl_FragColor = u_color;\n}\n","background.vert":"attribute vec2 a_pos;\n\nuniform highp mat3 u_dvsMat3;\nuniform mediump float u_coord_range;\nuniform mediump float u_depth;\n\nvoid main() {\n  vec3 v_pos = u_dvsMat3 * vec3(u_coord_range * a_pos, 1.0);\n  gl_Position = vec4(v_pos.xy, 0.0, 1.0);\n}\n"},bitBlit:{"bitBlit.frag":"uniform lowp sampler2D u_tex;\nuniform lowp float u_opacity;\n\nvarying mediump vec2 v_uv;\n\nvoid main() {\n  lowp vec4 color = texture2D(u_tex, v_uv);\n\n  // Note: output in pre-multiplied alpha for correct alpha compositing\n  gl_FragColor = color *  u_opacity;\n}\n","bitBlit.vert":"attribute vec2 a_pos;\nattribute vec2 a_tex;\n\nvarying mediump vec2 v_uv;\n\nvoid main(void) {\n  gl_Position = vec4(a_pos, 0.0, 1.0);\n  v_uv = a_tex;\n}\n"},highlight:{"blur.frag":"// A gaussian blur shader. It blurs the alpha channel of its input\n// according to 4 different sigma and stores the results into the\n// four channel of the target framebuffer.\n\n// It is intended to be called twice; the first time to perform an\n// horizontal blur, and a second time to perform a vertical blur.\n\n// This shader is used to turn the highlight mask into a highlight\n// map. The highlight map is an approximation of the signed distance\n// field of the mask.\n\n\n// Interpolated texture coordinates.\nvarying mediump vec2 v_texcoord;\n\n// Blur direction information. There are two possible\n// configurations that the host code can use.\n//  - [1, 0, 1/WIDTH, 0] Used when blurring horizontally. In this\n//    case u_direction[0] = 1 is expressed in pixel and is fed to\n//    the gauss function to produce the value of the gaussian weight\n//    for that pixel, while u_direction[2] = 1/WIDTH is in texel units\n//    and is used to sample the right texel from the texture map.\n//  - [0, 1, 0, 1/HEIGHT] Used when blurring vertically. In this\n//    case u_direction[1] = 1 is expressed in pixel and is fed to\n//    the gauss function to produce the value of the gaussian weight\n//    for that pixel, while u_direction[3] = 1/HEIGHT is in texel units\n//    and is used to sample the right texel from the texture map.\nuniform mediump vec4 u_direction;\n\n// Source to destination channel selection matrix.\nuniform mediump mat4 u_channelSelector;\n\n// The highlight map is obtained by blurring the alpha channel of the highlight\n// mask accroding to these 4 values of the gaussian's sigma parameter.\nuniform mediump vec4 u_sigmas;\n\n// This is the highlight mask if we have not blurred horizontally yet, otherwise\n// it is the horizontally blurred highlight map and blurring it one more time\n// vertically will complete the process.\nuniform sampler2D u_texture;\n\n// The gaussian kernel. Note that it lacks the normalization constant, because\n// we want to store it unnormalized in the highlight map (i.e. having a peak\n// value of 1). Note also that we are using the SIMD (single instruction, multiple\n// data) capabilities of the GPU to compute four different gaussian kernels, one\n// for each sigma.\nmediump vec4 gauss4(mediump vec2 dir) {\n  return exp(-dot(dir, dir) / (2.0 * u_sigmas * u_sigmas));\n}\n\n// Same as above but uses only channel 3, aka `w`, aka `q`, aka `a`.\nmediump float gauss1(mediump vec2 dir) {\n  return exp(-dot(dir, dir) / (2.0 * u_sigmas[3] * u_sigmas[3]));\n}\n\nmediump vec4 selectChannel(mediump vec4 sample) {\n  return u_channelSelector * sample;\n}\n\n// Sample the input texture and accumulated its gaussian weighted value and the\n// total weight; operates on all four channels.\nvoid accumGauss4(mediump float i, inout mediump vec4 tot, inout mediump vec4 weight) {\n  // Computes the gaussian weights, one for each sigma.\n  // Note that u_direction.xy is [1, 0] when blurring horizontally and [0, 1] when blurring vertically.\n  mediump vec4 w = gauss4(i * u_direction.xy);\n\n  // Accumumates the values.\n  // Note that u_direction.xy is [1/WIDTH, 0] when blurring horizontally and [0, 1/HEIGHT] when blurring vertically.\n  tot += selectChannel(texture2D(u_texture, v_texcoord + i * u_direction.zw)) * w;\n\n  // Accumulates the weights.\n  weight += w;\n}\n\n// Sample the input texture and accumulated its gaussian weighted value and the\n// total weight; operates on a single channel.\nvoid accumGauss1(mediump float i, inout mediump float tot, inout mediump float weight) {\n  // Computes the gaussian weights, using only the last sigma.\n  // Note that u_direction.xy is [1, 0] when blurring horizontally and [0, 1] when blurring vertically.\n  mediump float w = gauss1(i * u_direction.xy);\n\n  // Accumumates the values.\n  // Note that u_direction.xy is [1/WIDTH, 0] when blurring horizontally and [0, 1/HEIGHT] when blurring vertically.\n  tot += selectChannel(texture2D(u_texture, v_texcoord + i * u_direction.zw))[3] * w;\n\n  // Accumulates the weights.\n  weight += w;\n}\n\nvoid main(void) {\n  // Initialize accumulated values and weights to zero.\n  mediump float tot = 0.0;\n  mediump float weight = 0.0;\n\n  // Accumulates enough samples. These will be taken\n  // horizontally or vertically depending on the value\n  // of u_direction.\n  accumGauss1(-4.0, tot, weight);\n  accumGauss1(-3.0, tot, weight);\n  accumGauss1(-2.0, tot, weight);\n  accumGauss1(-1.0, tot, weight);\n  accumGauss1(0.0, tot, weight);\n  accumGauss1(1.0, tot, weight);\n  accumGauss1(2.0, tot, weight);\n  accumGauss1(3.0, tot, weight);\n  accumGauss1(4.0, tot, weight);\n\n  // Originally we were performing 4 blurs in parallel;\n  // Now we store the only result in the alpha component.\n  // dari8942: In theory we could disable writing to rgb\n  // using a color mask but I don't really feel like messing\n  // with that now.\n  gl_FragColor = vec4(0.0, 0.0, 0.0, tot / weight);\n}\n","highlight.frag":"// Takes as input the highlight map, estimated the signed distance field,\n// and shades the fragments according to their estimated distance from the\n// edge of the highlighted feature.\n\n// A shade texture is used to turn distance values into colors; the shade\n// texture is basically a color gradient and is recomputed on the host\n// every time that the user alters the highlight options.\n\n// Interpolated texture coordinates.\nvarying mediump vec2 v_texcoord;\n\n// The highlight map. Each channel is a blurred\n// version of the alpha channel of the highlight mask.\n//  - Channel 0 (red) corresponds to a gaussian blur with sigma = u_sigmas[0];\n//  - Channel 1 (green) corresponds to a gaussian blur with sigma = u_sigmas[1];\n//  - Channel 2 (blue) corresponds to a gaussian blur with sigma = u_sigmas[2];\n//  - Channel 3 (alpha) corresponds to a gaussian blur with sigma = u_sigmas[3];\n// As of today, only channel 3 is used for distance estimation.\n// But the availability of different amounts of blur leaves the\n// door open to multi-scale approaches.\nuniform sampler2D u_texture;\n\n// The highlight map was obtained by blurring the alpha channel of the highlight\n// mask accroding to these 4 values of the gaussian's sigma parameter.\nuniform mediump vec4 u_sigmas;\n\n// A 1-D texture used to shade the highlight.\nuniform sampler2D u_shade;\n\n// The 1-D shade texture is spreaded between u_minMaxDistance[0] and u_minMaxDistance[1].\nuniform mediump vec2 u_minMaxDistance;\n\n// Signed distance estimation.\nmediump float estimateDistance() {\n  // Use the largest sigma and the corresponding distance value stored in the\n  // last channel of the highlight map.\n  mediump float sigma = u_sigmas[3];\n  mediump float y = texture2D(u_texture, v_texcoord)[3];\n\n  // Estimates the distance by linearization and local inversion around\n  // the inflection point. The inflection point is in x = 0.\n  const mediump float y0 = 0.5;                           // Value of the convolution at the inflection point.\n  mediump float m0 = 1.0 / (sqrt(2.0 * 3.1415) * sigma);  // Slope of the convolution at the inflection point.\n  mediump float d = (y - y0) / m0;                        // Inversion of a local linearization.\n\n  // Return the estimated distance.\n  return d;\n}\n\n// Shading based on estimated distance.\nmediump vec4 shade(mediump float d) {\n  // Maps the sampled distance from the [A, D] range (see HighlightRenderer::setHighlightOptions) to [0, 1].\n  mediump float mappedDistance = (d - u_minMaxDistance.x) / (u_minMaxDistance.y - u_minMaxDistance.x);\n\n  // Force to [0, 1]; it should not be necessary because the shade texture uses the CLAMP address mode, so\n  // this should happen anyway internally to the sampler, but in practice it is needed to avoid weird\n  // banding artifacts.\n  // We don't really know if we need this or not.\n  mappedDistance = clamp(mappedDistance, 0.0, 1.0);\n\n  // Sample the 1-D shade texture on its center line (i.e. on t=0.5).\n  return texture2D(u_shade, vec2(mappedDistance, 0.5));\n}\n\nvoid main(void) {\n  // Estimate the distance.\n  mediump float d = estimateDistance();\n\n  // Shade the distance.\n  gl_FragColor = shade(d);\n}\n","textured.vert":"// Identity vertex shader that outputs an untransformed 2-D vertex\n// and passes its texture coordinates unchanged to the interpolator.\n\n// Vertex position.\nattribute mediump vec2 a_position;\n\n// Texture coordinates.\nattribute mediump vec2 a_texcoord;\n\n// Texture coordinates to be interpolated.\nvarying mediump vec2 v_texcoord;\n\nvoid main(void) {\n  // Pass the position unchanged.\n  gl_Position = vec4(a_position, 0.0, 1.0);\n\n  // Pass the texture coordinates unchanged.\n  v_texcoord = a_texcoord;\n}\n"},magnifier:{"magnifier.frag":"uniform lowp vec4 u_background;\nuniform mediump sampler2D u_readbackTexture;\nuniform mediump sampler2D u_maskTexture;\nuniform mediump sampler2D u_overlyTexture;\n\nvarying mediump vec2 v_texCoord;\n\nvoid main(void)\n{\n  lowp vec4 color = texture2D(u_readbackTexture, v_texCoord);\n  color = color + (1.0 - color.a) * u_background;\n\n  // calculate the grayscale value of the mask:\n  lowp vec4 mask_color = texture2D(u_maskTexture, v_texCoord);\n  lowp float gray = 1.0 - dot(mask_color, vec4(0.3, 0.59, 0.11, 0));\n  // make all the map color outside the mask black\n  color *= gray;\n\n  lowp vec4 overley_color = texture2D(u_overlyTexture, v_texCoord);\n\n  // premultiply the overlay color\n  overley_color.rgb *= overley_color.a;\n  gl_FragColor = overley_color + (1.0 - overley_color.a) * color;\n}\n","magnifier.vert":"precision mediump float;\n\nattribute mediump vec2 a_pos; // encoded values are 0 and 1\n\nuniform mediump vec2 u_drawPos; // the center position of the magnifier\nuniform mediump float u_width; // the width of the magnifier in normalized display coords\nuniform mediump float u_height; // the height of the magnifier in normalized display coords\n\nvarying mediump vec2 v_texCoord;\n\n\nvoid main(void)\n{\n  v_texCoord = a_pos;\n  vec2 coord = u_drawPos + vec2(a_pos - 0.5) * vec2(u_width, u_height);\n  gl_Position = vec4(coord, 0.0, 1.0);\n}\n"},materials:{"constants.glsl":"const float C_DEG_TO_RAD = 3.14159265359 / 180.0;\nconst float SIGNED_BYTE_TO_UNSIGNED = 128.0;\n\n// markers\nconst float SOFT_EDGE_RATIO = 1.0; // use blur here if needed\n\n// lines\nconst float THIN_LINE_WIDTH_FACTOR = 1.1;\n\n// meaning that a 2 pixels line width is considered a thin line\nconst float THIN_LINE_HALF_WIDTH = 1.0;\n\n// labels \nconst float OFFSET_PRECISION = 1.0 / 8.0;\nconst float OUTLINE_SCALE = 1.0 / 5.0;\nconst float SDF_FONT_SIZE = 24.0;\n\n// maximum SDF distance of 8 pixels represent the distance values that range from -2 inside the\n// geometry to 6 on the outside. 6 is actually the maximum distance outside the glyph, therefore\n// it is the limitation of the halo which is 1/4 of the geometry size.\nconst float MAX_SDF_DISTANCE = 8.0;\n\nconst float PLACEMENT_PADDING = 8.0;\n\n\nconst float EPSILON = 0.0000001; \n\nconst int MAX_FILTER_COUNT = 2;\n","effects.glsl":"\nuniform mat4 u_insideEffectMat4[ MAX_FILTER_COUNT ];\nuniform mat4 u_outsideEffectMat4[ MAX_FILTER_COUNT ];\n\nvec4 getEffectColor(in vec4 color, in float filterFlags) {\n  vec4 outColor = vec4(color);\n\n  // default visibility filter is index 0, index 1+ are effects\n  for (int i = 1; i < EFFECT_COUNT + 1; i++) {\n    float bit = getBit(filterFlags, i);\n    \n    outColor = u_insideEffectMat4[ i ] * (bit  * outColor) + u_outsideEffectMat4[ i ] * ((1.0 - bit) * outColor);\n  }\n  \n  return outColor; \n}\n\nvoid applyFilter(inout vec4 color, inout vec3 pos, in float filterFlags) {\n\n  // default visibility filter is index 0, index 1+ are effects\n  for (int i = 0; i < EFFECT_COUNT + 1; i++) {\n    float bit = getBit(filterFlags, i); \n\n    color = u_insideEffectMat4[ i ] * (bit  * color) + u_outsideEffectMat4[ i ] * ((1.0 - bit) * color);\n  }\n\n  // If we are not visible, clip the vertex if we are doing a hit-test\n  pos.z += 2.0 * (1.0 - getBit(filterFlags, 0)); \n}\n\nvoid applyFilterLabels(inout vec4 color, inout vec3 pos, in float filterFlags) {\n  float bit = getBit(filterFlags, 0); \n\n  pos.z += 2.0 * (1.0 - bit);\n\n  // When outsideLabelsVisible is false, we also clip labels if they fail any effect filter\n#ifndef OUTSIDE_LABELS_VISIBLE\n  for (int i = 1; i < EFFECT_COUNT + 1; i++) {\n    float bit = getBit(filterFlags, i); \n\n    pos.z += 2.0 * (1.0 - bit);\n  }\n#endif\n}\n",fill:{"fill.frag":"precision highp float;\n\n#include <materials/constants.glsl>\n\n#ifdef ID\n\nvarying highp vec4 v_id;\n\n#endif // ID\n\n#ifdef PATTERN\n\nuniform lowp sampler2D u_texture;\n\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_tileTextureCoord;\n\n#endif // PATTERN\n\n#ifdef DOT_DENSITY\n\nuniform mediump mat4 u_dotColors[ 2 ];\nuniform sampler2D u_dotTextures[ 2 ];\nuniform vec4 u_dotBackgroundColor;\n\nvarying highp vec4 v_dotThresholds[ 2 ];\nvarying vec2 v_dotTextureCoords;\n\n#endif\n\nvarying lowp vec4 v_color;\nvarying lowp float v_opacity;\n\nfloat max4(vec4 target) {\n  return max(max(max(target.x, target.y), target.z), target.w);\n}\n\nvoid main() {\n\n#ifdef ID\n\n  gl_FragColor = v_id;\n\n#elif defined(PATTERN)\n\n  // normalize the calculated texture coordinate such that it fits in the range of 0 to 1.\n  mediump vec2 normalizedTextureCoord = mod(v_tileTextureCoord, 1.0);\n  // interpolate the image coordinate between the top-left and the bottom right to get the actual position to sample.\n  // after normalizing the position, we get a value ranging between 0 and 1 which refers to the entire texture, however\n  // we need to only sample from area that has our sprite in the mosaic.\n  mediump vec2 samplePos = mix(v_tlbr.xy, v_tlbr.zw, normalizedTextureCoord);\n  // sample the sprite mosaic\n  lowp vec4 color = texture2D(u_texture, samplePos);\n  gl_FragColor = v_opacity * v_color * color;\n\n#elif defined(DOT_DENSITY) && !defined(HIGHLIGHT)\n\n  vec4 textureThresholds0 = texture2D(u_dotTextures[0], v_dotTextureCoords);\n  vec4 textureThresholds1 = texture2D(u_dotTextures[1], v_dotTextureCoords);\n\n  vec4 difference0 = v_dotThresholds[0] - textureThresholds0;\n  vec4 difference1 = v_dotThresholds[1] - textureThresholds1;\n\n#ifdef DD_DOT_BLENDING\n\n  vec4 isPositive0 = step(0.0, difference0);\n  vec4 isPositive1 = step(0.0, difference1);\n\n  float weightSum = dot(isPositive0, difference0) + dot(isPositive1, difference1);\n  float lessThanEqZero = step(weightSum, 0.0);\n  float greaterThanZero = 1.0 - lessThanEqZero ;\n  float divisor = (weightSum + lessThanEqZero); // Guard against divide by zero\n\n  vec4 weights0 = difference0 * isPositive0 / divisor;\n  vec4 weights1 = difference1 * isPositive1 / divisor;\n\n  vec4 dotColor = u_dotColors[0] * weights0 + u_dotColors[1] * weights1;\n\n  gl_FragColor = greaterThanZero * dotColor + lessThanEqZero * u_dotBackgroundColor;\n\n#else\n\n  float diffMax = max(max4(difference0), max4(difference1));\n  float lessThanZero = step(diffMax, 0.0);\n  float greaterOrEqZero = 1.0 - lessThanZero;\n\n  vec4 isMax0 = step(diffMax, difference0);\n  vec4 isMax1 = step(diffMax, difference1);\n\n  vec4 dotColor = u_dotColors[0] * isMax0 + u_dotColors[1] * isMax1;\n\n  gl_FragColor = greaterOrEqZero * dotColor + lessThanZero * u_dotBackgroundColor;\n\n#endif\n\n#else\n\n  gl_FragColor = v_opacity * v_color;\n\n#endif // PATTERN\n\n#ifdef HIGHLIGHT\n\n  gl_FragColor.a = 1.0;\n\n#endif // HIGHLIGHT\n}\n","fill.vert":"precision mediump float;\n\n#include <materials/constants.glsl>\n#include <materials/utils.glsl>\n#include <materials/vv.glsl>\n#include <materials/effects.glsl>\n\nattribute vec2 a_pos;\nattribute vec4 a_id;                // objectId in RGBA components\nattribute float  a_visible;         // one byte controlling the visibility of the vertex (separate buffer),\n\n#ifndef DOT_DENSITY\nattribute vec4 a_color;\nattribute vec4 a_tlbr;\nattribute vec4 a_aux1;\nattribute vec2 a_aux2;\nattribute vec4 a_aux3;              // encodes a bitset (CIM) detailing vv locking\n#endif\n\n#if defined(VV_COLOR) || defined(VV_OPACITY)\nattribute highp vec4 a_vv;\n#endif\n\nuniform highp mat3 u_dvsMat3;      // premultiplies DisplayMat3 * ViewMat3 * ScreenMat3\nuniform highp float u_pixelRatio;\n\nvarying lowp vec4 v_color;\nvarying lowp float v_opacity;\n\n#ifdef ID\nvarying highp vec4 v_id;\n#endif\n\n#ifdef PATTERN\nuniform mediump float u_zoomFactor;\nuniform mediump vec2 u_mosaicSize;\n\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_tileTextureCoord;\n#endif\n\n#ifdef DOT_DENSITY\nattribute highp vec4 a_dd1;\nattribute highp vec4 a_dd2;\n\nuniform float u_dotValue;\nuniform float u_tileDotsOverArea; \n\nuniform float u_dotTextureDotCount;\nuniform float u_tileZoomFactor; \n\nvarying vec4 v_dotThresholds[ 2 ]; \nvarying vec2 v_dotTextureCoords;\n\nvec4 dotThreshold(vec4 featureAttrOverFeatureArea, float dotValue, float tileDotsOverArea) {\n  return featureAttrOverFeatureArea * (1.0 / dotValue)  * (1.0 / tileDotsOverArea);\n}\n#endif\n\nvoid main()\n{\n// Arguably DotDensity should be extracted to its own shader. This gets a bit\n// fungly because DD uses a signifcantly different stride\n#ifndef DOT_DENSITY \n  float a_bitset = a_aux3.w; \n  float isColorLocked = getBit(a_bitset, 0);\n  \n  v_color = a_color;\n#else\n  v_color = vec4(0.0, 0.0, 0.0, 1.0);    // for highlight\n#endif\n  v_opacity = 1.0;\n  \n#ifdef ID\n  v_id = a_id;\n#endif\n  \n#ifdef VV_OPACITY\n  v_opacity = getVVOpacity(a_vv.y);\n#endif\n  \n#ifdef VV_COLOR\n  v_color = getVVColor(a_vv.x, v_color, isColorLocked);\n#endif\n  \n#ifdef PATTERN\n  vec2 aux2 = (1.0 / SIGNED_BYTE_TO_UNSIGNED) * a_aux2;\n  vec2 symbolOffset = u_zoomFactor * (a_aux1.zw - SIGNED_BYTE_TO_UNSIGNED);\n  mat3 patternMatrix = mat3(1.0);\n\n  // calculate the pattern matrix\n  patternMatrix[0][0] = 1.0 / (u_zoomFactor * a_aux1.x * aux2.x);\n  patternMatrix[1][1] = 1.0 / (u_zoomFactor * a_aux1.y * aux2.y);\n\n  // calculate the texture coordinates of the current vertex. It will of course get interpolated.\n  // The pattern matrix is a 3x3 scale matrix which 'tiles' the texture inside the tile, translating from\n  // tile coordinates to texture coordinates.\n  v_tileTextureCoord = (patternMatrix * vec3(a_pos + symbolOffset, 1.0)).xy;\n  v_tlbr = a_tlbr / u_mosaicSize.xyxy;\n\n#elif defined(DOT_DENSITY)\n  float size = u_tileZoomFactor * 512.0 * 1.0 / u_pixelRatio;\n\n  v_dotThresholds[0] = dotThreshold(a_dd1, u_dotValue, u_tileDotsOverArea);\n  v_dotThresholds[1] = dotThreshold(a_dd2, u_dotValue, u_tileDotsOverArea);\n  v_dotTextureCoords = (a_pos + 0.5) / size;\n\n#endif\n  vec3 v_pos = u_dvsMat3 * vec3(a_pos, 1.);\n\n  applyFilter(v_color, v_pos, a_visible);\n  \n  gl_Position = vec4(v_pos, 1.0);\n}\n"},icon:{"icon.frag":"precision mediump float;\n\n#include <materials/constants.glsl>\n#include <materials/utils.glsl>\n#include <util/encoding.glsl>\n#include <materials/effects.glsl>\n#include <materials/constants.glsl>\n\nuniform lowp sampler2D u_texture;\n\nvarying lowp vec2 v_tex;\nvarying lowp float v_transparency;\nvarying mediump vec2 v_size;\nvarying lowp vec4 v_color;\nvarying float v_visible;\n\n#ifdef SDF\nvarying lowp vec4 v_outlineColor;\nvarying mediump float v_outlineWidth;\nvarying float v_overridingOutlineColor;\n#endif // SDF\n\n#ifdef HIGHLIGHT\nvarying float v_isThinGeometry;\n#endif // HIGHLIGHT\n\n#ifdef ID\nvarying highp vec4 v_id;\n#endif // ID\n\nvoid main()\n{\n#ifdef SDF\n  lowp vec4 fillPixelColor = v_color;\n\n  // calculate the distance from the edge [-0.5, 0.5]\n  float d = 0.5 - rgba2float(texture2D(u_texture, v_tex));\n\n  // the soft edge ratio is about 1.5 pixels allocated for the soft edge.\n  float size = max(v_size.x, v_size.y);\n  float dist = d * size * SOFT_EDGE_RATIO;\n\n  // set the fragment's transparency according to the distance from the edge\n  fillPixelColor *= clamp(0.5 - dist, 0.0, 1.0);\n\n  float outlineWidth = v_outlineWidth;\n\n  #ifdef HIGHLIGHT\n    outlineWidth = max(outlineWidth, 4.0 * v_isThinGeometry);\n  #endif\n\n  // count for the outline\n  // therefore tint the entire icon area.\n  if (outlineWidth > 0.25) {\n    lowp vec4 outlinePixelColor = v_overridingOutlineColor * v_color + (1.0 - v_overridingOutlineColor) * v_outlineColor;\n\n    // outlines can't be larger than the size of the symbol\n    float clampedOutlineSize = min(outlineWidth, size);\n\n    outlinePixelColor *= clamp(0.5 - abs(dist) + clampedOutlineSize * 0.5, 0.0, 1.0);\n\n    // finally combine the outline and the fill colors (outline draws on top of fill)\n    gl_FragColor = v_transparency * ((1.0 - outlinePixelColor.a) * fillPixelColor + outlinePixelColor);\n  }\n  else {\n    gl_FragColor = v_transparency * fillPixelColor;\n  }\n#else // not an SDF\n   lowp vec4 texColor = texture2D(u_texture, v_tex);\n   gl_FragColor = v_transparency * getEffectColor(texColor, v_visible);\n#endif // SDF\n\n#ifdef HIGHLIGHT\n  gl_FragColor.a = step(1.0 / 255.0, gl_FragColor.a);\n#endif // HIGHLIGHT\n\n#ifdef ID\n  if (gl_FragColor.a < 1.0 / 255.0) {\n    discard;\n  }\n  gl_FragColor = v_id;\n#endif // ID\n}\n","icon.vert":"precision mediump float;\n\n#include <materials/constants.glsl>\n#include <materials/utils.glsl>\n#include <materials/vv.glsl>\n#include <materials/effects.glsl>\n\nattribute vec2 a_pos;\nattribute vec4 a_vertexOffsetAndTex;\nattribute vec4 a_id;                   // objectId in RGBA components\nattribute vec4 a_color;\nattribute vec4 a_outlineColor;\nattribute vec4 a_sizeAndOutlineWidth;\nattribute float a_visible;             // one byte controlling the vertex visibility (separate buffer)\n\n#ifdef VV\nattribute highp vec4 a_vv;\n#endif\n\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform highp mat3 u_displayViewMat3;\nuniform vec2 u_mosaicSize;            // mosaic size in pixels\n\nvarying lowp vec4 v_color;\nvarying mediump vec2 v_tex;           // texture coordinates used to sample the sprite atlas\nvarying lowp float v_transparency;    // the calculated transparency to be applied by the fragment shader.\nvarying mediump vec2 v_size;          // icon size in px\nvarying float v_visible;\n\n#ifdef SDF\nvarying lowp vec4 v_outlineColor;\nvarying mediump float v_outlineWidth;\nvarying float v_overridingOutlineColor;\n#endif\n\n#ifdef HIGHLIGHT\nvarying float v_isThinGeometry;\n#endif // HIGHLIGHT\n\n#ifdef ID\nvarying highp vec4 v_id;\n#endif\n\nvec2 getMarkerSize(inout vec2 offset, in vec2 baseSize, in float vvSize) {\n  float f = getVVSize(baseSize.y, vvSize);\n  vec2 size = vec2(f * baseSize.x / baseSize.y, f);\n\n  offset *= (size / baseSize);\n  return size;\n}\n\nvoid main()\n{\n  vec2 offset = a_vertexOffsetAndTex.xy;\n  vec2 a_tex = a_vertexOffsetAndTex.zw + SIGNED_BYTE_TO_UNSIGNED;\n  vec2 a_size = a_sizeAndOutlineWidth.xy;\n  float a_bitset = a_sizeAndOutlineWidth.w;\n\n  float isMapAligned = getBit(a_bitset, 0);\n  float isColorLocked = getBit(a_bitset, 1);\n  float isThinGeometry = getBit(a_bitset, 2);\n  mat3 offsetMat3 = isMapAligned * u_displayViewMat3 + (1.0 - isMapAligned) * u_displayMat3;\n\n  v_transparency = 1.0;\n  v_color = a_color;\n  v_size = a_size;\n  v_tex = a_tex / u_mosaicSize; // texture coords and transparency\n  v_visible = a_visible;\n\n#ifdef ID\n  v_id = a_id;\n#endif\n\n#ifdef VV_OPACITY\n  v_transparency = getVVOpacity(a_vv.z);\n#endif\n\n#ifdef VV_COLOR\n  v_color = getVVColor(a_vv.y, a_color, isColorLocked);\n#endif // VV_COLOR\n\n#ifdef VV_SIZE\n  v_size = getMarkerSize(offset, a_size, a_vv.x);\n#endif\n\n#ifdef VV_ROTATION\n  offset = (getVVRotationMat3(a_vv.w) * vec3(offset, 0.0)).xy;\n#endif\n\n#ifdef SDF\n  #ifdef VV_COLOR\n    // this is true only if we have SDF and color VV\n    v_overridingOutlineColor = isThinGeometry;\n  #else\n    v_overridingOutlineColor = 0.0;\n  #endif\n\n  offset *= 2.0;\n  v_outlineColor = getEffectColor(a_outlineColor, a_visible);\n  // YF: in practice v_size.x and v_size.y are identical since we're mostly dealing with sms\n  v_outlineWidth = min(a_sizeAndOutlineWidth.z, max(v_size.x - 0.99, 0.0));\n#endif\n\n#ifdef HIGHLIGHT\n  v_isThinGeometry = isThinGeometry;\n#endif\n\n  vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + offsetMat3 * vec3(offset, 0.0);\n\n  applyFilter(v_color, pos, a_visible);\n\n  gl_Position = vec4(pos, 1.0);\n}\n"},label:{"label.frag":"precision lowp float;\n\nuniform mediump sampler2D u_referenceTex;\nuniform mediump vec2 u_screenSize;\nuniform mediump float u_pixelRatio;\n\nvarying mediump float v_antialiasingWidth;\nvarying mediump float v_edgeDistanceOffset;\nvarying mediump vec2 v_tex;\n\n#ifdef ID\nvarying mediump float v_fadeStep;\n#else\nuniform lowp sampler2D u_texture;\nvarying mediump vec4 v_color;\n#endif // ID\n\nconst vec3 epsilon = vec3(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0);\n\nvoid main()\n{\n  mediump vec2 refTextPos = gl_FragCoord.xy / (u_pixelRatio * u_screenSize.xy);\n  mediump vec4 referenceFragment = texture2D(u_referenceTex, refTextPos);\n#ifdef ID\n  mediump float alpha = clamp(referenceFragment.a + v_fadeStep, 0.0, 1.0);\n  // fill the whole quad\n  gl_FragColor = vec4(alpha);\n#else\n  // read the fade alpha\n  lowp float fadeAlpha = referenceFragment.a;\n\n  // read the distance from the SDF texture\n  lowp float dist = texture2D(u_texture, v_tex).a;\n\n  // the edge distance if a factor of the outline width\n  // We cap this to 0.25 to prevent this from becomming negative / running into the glyph boundaries\n  float glyphEdgeDistance = max(0.75 - v_edgeDistanceOffset, 0.25);\n\n  // use a smooth-step in order to calculate the geometry of the shape given by the distance field\n  lowp float sdfAlpha = smoothstep(glyphEdgeDistance - v_antialiasingWidth, glyphEdgeDistance + v_antialiasingWidth, dist);\n\n  gl_FragColor = fadeAlpha * sdfAlpha * v_color;\n#endif\n}\n","label.vert":"precision mediump float;\n\n#include <materials/constants.glsl>\n#include <materials/utils.glsl>\n#include <materials/vv.glsl>\n#include <materials/effects.glsl>\n\nattribute vec2 a_pos;                         // (2 x i16)\nattribute vec4 a_color;                       // (4 x u8)\nattribute vec2 a_vertexOffset;                // (2 x i16) offset from the anchor point of the string\nattribute vec4 a_texAndSize;                  // (4 x u8) texture coordinatesm and font size. w is for the halo size\nattribute vec4 a_refSymbolAndPlacementOffset; // (4 x u8) reference symbol offset (px) and the placement offset (px)\nattribute float a_vvSize;                     // size visual variable\nattribute lowp float  a_visible;              // a one byte controlling the visibility of the vertex (separate buffer)\nattribute mediump vec2 a_visibilityRange;     // (2 x u8);\n\nuniform mediump float u_zoomLevel;            // the current zoom level X 10\nuniform highp mat3 u_dvsMat3;                 // premultiplies displayMat3 * viewMat3 * screenMat3\nuniform highp mat3 u_displayMat3;\nuniform float u_mapRotation;\nuniform float u_mapAligned;\nuniform vec2 u_mosaicSize;\nuniform float u_pixelRatio;\n\nvarying mediump float v_antialiasingWidth;\nvarying mediump float v_edgeDistanceOffset;\nvarying mediump vec2 v_tex;                   // texture coordinates used to sample the glyph atlas\nvarying mediump vec4 v_color;\n\n#ifdef ID                                     // somewhat of a misnomer - id is used here for the label alpha phase\nuniform mediump float u_fadeStep; \nvarying mediump float v_fadeStep;\n#endif\n\nfloat getZ(in float minZoom, in float maxZoom, in float angle) {\n  float glyphAngle = angle * 360.0 / 254.0;\n  float mapAngle = u_mapRotation * 360.0 / 254.0;\n  float diffAngle = min(360.0 - abs(mapAngle - glyphAngle), abs(mapAngle - glyphAngle));\n  float z = 0.0;\n\n  // make sure range is inclusive\n  z += 2.0 * (1.0 - step(minZoom, u_zoomLevel));\n  z += 2.0 * (1.0 - step(u_zoomLevel, maxZoom));\n  z += 2.0 * u_mapAligned * step(90.0, diffAngle);\n  return z;\n}\n\nvoid main()\n{\n  float isHalo = mod(a_pos, 2.0).x; // lsb of a_pos denotes whether a vertex is part of the halo or not\n  vec3 pos = vec3(floor(a_pos * 0.5), 1.0);\n  vec2 placementDir = a_refSymbolAndPlacementOffset.zw - 1.0;  // encoded as dir + 1.0\n  vec2 vertexOffset = a_vertexOffset * OFFSET_PRECISION;\n  float refSymbolSize = a_refSymbolAndPlacementOffset.y;\n  float fontSize = a_texAndSize.z;\n  float z = getZ(a_visibilityRange.x, a_visibilityRange.y, a_refSymbolAndPlacementOffset.x);\n\n  float fontScale = fontSize / SDF_FONT_SIZE;\n  float halfSize = refSymbolSize / 2.0;\n\n  v_color = a_color;\n  v_tex = a_texAndSize.xy / u_mosaicSize;\n\n#ifdef ID\n  v_fadeStep = u_fadeStep;\n#endif\n  \n#ifdef VV_SIZE // unlike with text, this is the VV_SIZE of the reference symbol, not the label itself\n  halfSize = getVVSize(refSymbolSize, a_vvSize) / 2.0;\n#endif\n  // if halo.x is zero (not a halo) v_edgeDistanceOffset will end up being zero as well.\n  v_edgeDistanceOffset = isHalo * OUTLINE_SCALE * a_texAndSize.w / fontScale / MAX_SDF_DISTANCE;\n  v_antialiasingWidth = 0.106 * SDF_FONT_SIZE / fontSize / u_pixelRatio;\n\n  vec2 placementOffset = placementDir * (halfSize + PLACEMENT_PADDING);\n  vec3 glyphOffset = u_displayMat3 * vec3(vertexOffset + placementOffset, 0.0);\n  vec3 v_pos = u_dvsMat3 * pos + glyphOffset;\n  \n  applyFilterLabels(v_color, v_pos, a_visible);\n\n#ifdef DEBUG\n  v_color = vec4(a_color.rgb, z == 0.0 ? 1.0 : 0.645);  // visualize hidden glyphs\n#endif\n  \n  gl_Position = vec4(v_pos.xy, v_pos.z + z, 1.0);\n}\n"},line:{"line.frag":"precision lowp float;\n\n#include <util/encoding.glsl>\n#include <materials/constants.glsl>\n\nuniform lowp float u_blur;\nuniform mediump float u_antialiasing;\n\nvarying mediump vec2 v_normal;\nvarying mediump float v_lineHalfWidth;\nvarying lowp vec4 v_color;\nvarying lowp float v_transparency;\n\n#if defined(PATTERN) || defined(SDF)\nuniform sampler2D u_texture;\nuniform mediump float u_zoomFactor;\n\nvarying mediump vec4 v_tlbr; // normalized pattern coordinates [0, 1]\nvarying mediump vec2 v_patternSize;\nvarying highp float v_accumulatedDistance;\n#endif // PATTERN SDF\n\n#ifdef SDF\nconst float sdfPatternHalfWidth = 15.5; // YF: assumed that the width will be set to 31\nconst float widthFactor = 2.0;\n#endif // SDF\n\n#ifdef ID\nvarying highp vec4 v_id;\n#endif // ID\n\n\nvoid main()\n{\n  // for now assume that a thin line is a line which is under 2 pixels (1 pixels on either sides of the centerline)\n  mediump float thinLineFactor = max(THIN_LINE_WIDTH_FACTOR * step(v_lineHalfWidth, THIN_LINE_HALF_WIDTH), 1.0);\n\n  // dist represent the distance of the fragment from the line. 1.0 or -1.0 will be the values on the edge of the line,\n  // and any value in between will be inside the line (the sign represent the direction - right or left).\n  // since u_linewidth.s (half line width) is represented in pixels, dist is also given in pixels\n  mediump float fragDist = length(v_normal) * v_lineHalfWidth;\n\n  // calculate the alpha given the difference between the line-width and the distance of the fragment from the center-line.\n  // when it is a thin line then use a slightly shallower slope in order to add more feathering\n  lowp float alpha = clamp(thinLineFactor * (v_lineHalfWidth - fragDist) / (u_blur + thinLineFactor - 1.0), 0.0, 1.0);\n\n#if defined(SDF) && !defined(HIGHLIGHT) // When we render the highlight, we want to treat the line as if it was solid\n  mediump float lineHalfWidth = widthFactor * v_lineHalfWidth;\n  mediump float lineWidthRatio = lineHalfWidth / sdfPatternHalfWidth;\n  mediump float relativeTexX = mod((u_zoomFactor * v_accumulatedDistance + v_normal.x * lineHalfWidth) / (lineWidthRatio * v_patternSize.x), 1.0);\n  mediump float relativeTexY = 0.5 + 0.5 * v_normal.y;\n\n  // claculate the actual texture coordinates by interpolating between the TL/BR pattern coordinates\n  mediump vec2 texCoord = mix(v_tlbr.xy, v_tlbr.zw, vec2(relativeTexX, relativeTexY));\n\n  // calculate the distance from the edge [-0.5, 0.5]\n  mediump float d = rgba2float(texture2D(u_texture, texCoord)) - 0.5;\n\n  // the distance is a proportional to the line width\n  float dist = d * lineHalfWidth;\n\n  lowp vec4 fillPixelColor = v_transparency * alpha * clamp(0.5 - dist, 0.0, 1.0) * v_color;\n  gl_FragColor = fillPixelColor;\n#elif defined(PATTERN) && !defined(HIGHLIGHT)  // When we render the highlight, we want to treat the line as if it was solid\n  // we need to calculate the relative portion of the line texture along the line given the accumulated distance along the line\n  // The computed value should is anumber btween 0 and 1 which will later be used to interpolate btween the BR and TL values\n  mediump float relativeTexX = mod((u_zoomFactor * v_accumulatedDistance + v_normal.x * v_lineHalfWidth) / v_patternSize.x, 1.0);\n\n  // in order to calculate the texture coordinates prependicular to the line (Y axis), we use the interpolated normal values\n  // which range from -1.0 to 1.0. On the line's centerline, the value of the interpolated normal is 0.0, however the relative\n  // texture value shpould be 0.5 (given that at the bottom of the line, the texture coordinate must be equal to 0.0)\n  // (TL) ---------------------------      --\x3e left edge of line. Interpolatedf normal is 1.0\n  //              | -> line-width / 2\n  //      - - - - - - - - - - - - - -\n  //              | -> line-width / 2\n  //      ---------------------------- (BR)--\x3e right edge of line. Interpolatedf normal is -1.0\n\n  mediump float relativeTexY = 0.5 + (v_normal.y * v_lineHalfWidth / v_patternSize.y);\n\n  // claculate the actual texture coordinates by interpolating between the TL/BR pattern coordinates\n  mediump vec2 texCoord = mix(v_tlbr.xy, v_tlbr.zw, vec2(relativeTexX, relativeTexY));\n\n  // get the color from the texture\n  lowp vec4 color = texture2D(u_texture, texCoord);\n\n  gl_FragColor = v_transparency * alpha * v_color * color;\n#else // solid line (no texture, no pattern)\n  // output the fragment color\n  gl_FragColor = v_transparency * alpha * v_color;\n#endif // SDF\n\n#ifdef HIGHLIGHT\n  gl_FragColor.a = step(1.0 / 255.0, gl_FragColor.a);\n#endif // HIGHLIGHT\n\n#ifdef ID\n  if (gl_FragColor.a < 1.0 / 255.0) {\n    discard;\n  }\n  gl_FragColor = v_id;\n#endif // ID\n}\n","line.vert":"precision mediump float;\n\n#include <materials/constants.glsl>\n#include <materials/utils.glsl>\n#include <materials/vv.glsl>\n#include <materials/effects.glsl>\n\nattribute vec2 a_pos;\nattribute vec4 a_id;\nattribute vec4 a_color;\nattribute vec4 a_offsetAndNormal;\nattribute vec2 a_accumulatedDistanceAndHalfWidth;\nattribute vec4 a_tlbr;\nattribute vec4 a_segmentDirection;\nattribute float  a_visible;                // a one byte controlling the visibility of the vertex (separate buffer)\n\n#ifdef VV\nattribute highp vec3 a_vv;\n#endif\n\nuniform highp mat3 u_dvsMat3;              // premultiplies DisplayMat3 * ViewMat3 * ScreenMat3\nuniform highp mat3 u_displayViewMat3;     // premultiplies DisplayMat3 * ViewMat3\nuniform mediump float u_zoomFactor;\nuniform mediump float u_antialiasing;\n\nvarying mediump vec2 v_normal;             // interpolated normal to the line. packed into the two LSBs of the vertex coordinate\nvarying mediump float v_lineHalfWidth;\nvarying lowp vec4 v_color;\nvarying lowp float v_transparency;\n\n#ifdef ID\nvarying highp vec4 v_id;\n#endif\n\n#ifdef PATTERN\nuniform mediump vec2 u_mosaicSize;\n\nvarying mediump vec4 v_tlbr;               // normalized pattern coordinates [0, 1]\nvarying mediump vec2 v_patternSize;\n#endif\n\n#if defined(PATTERN) || defined(SDF)\nvarying highp float v_accumulatedDistance; // we need to accumulated distance only if it is a pattern or an SDF line\n#endif\n\n#if defined(SDF) && !defined(HIGHLIGHT) // When we render the highlight, we want to treat the line as if it was solid\nconst float widthFactor = 2.0;\n#else\nconst float widthFactor = 1.0;\n#endif\n\nconst float scale = 1.0 / 31.0;\n\nvoid main()\n{\n  float a_bitset = a_segmentDirection.w;\n\n  float isColorLocked = getBit(a_bitset, 0);\n  float lineHalfWidth = a_accumulatedDistanceAndHalfWidth.y * scale;\n\n  v_transparency = 1.0;\n  v_color = a_color;\n  v_normal = a_offsetAndNormal.zw * scale;\n\n#ifdef ID\n  v_id = a_id;\n#endif\n\n#ifdef VV_OPACITY\n  v_transparency = getVVOpacity(a_vv.z);\n#endif\n\n#ifdef VV_COLOR\n  v_color = getVVColor(a_vv.y, v_color, isColorLocked);\n#endif\n\n#ifdef VV_SIZE\n  lineHalfWidth = 0.5 * getVVSize(2.0 * lineHalfWidth, a_vv.x);\n#endif\n\n#ifdef PATTERN\n  v_tlbr = a_tlbr / u_mosaicSize.xyxy;\n  v_patternSize = vec2(a_tlbr.z - a_tlbr.x, a_tlbr.w - a_tlbr.y);\n#endif\n\n  // make sure to clip the vertices in case that the width of the line is 0 (or negative)\n  float z = 2.0 * step(lineHalfWidth, 0.0);\n\n  // add an antialiasing distance. We use 0.2 rather than 0.5 in order to match the SVG renderer\n  // also limit the total line width to 1.3 pixels. Below this value lines don't look good compared\n  // to the SVG renderer\n  v_lineHalfWidth = max(lineHalfWidth, 0.45) + 0.2 * u_antialiasing;\n\n\n#ifdef HIGHLIGHT\n  v_lineHalfWidth = max(v_lineHalfWidth, 2.0);\n#endif\n\n  // for now assume that a thin line is a line which is under 2 pixels (1 pixels on either sides\n  // of the centerline) in practice, a thin line is a line who's half width vary from 0.45px to\n  // the value of thinLineHalfWidth, as the value is claped in line 221 above\n  mediump float thinLineFactor = max(THIN_LINE_WIDTH_FACTOR * step(v_lineHalfWidth, THIN_LINE_HALF_WIDTH), 1.0);\n\n  // calculate the relative distance from the centerline to the edge of the line. Since offset is\n  // given in integers (for the sake of using less attribute memory, we need to scale it back to\n  // the original range of ~ [0, 1]) in a case of a thin line we move each vertex twice as far\n  mediump vec2 dist = thinLineFactor * widthFactor * v_lineHalfWidth * a_offsetAndNormal.xy * scale;\n\n#if defined(PATTERN) || defined(SDF)\n  v_accumulatedDistance = a_accumulatedDistanceAndHalfWidth.x + dot(scale * a_segmentDirection.xy, dist / u_zoomFactor);\n#endif\n\n  vec3 offset = u_displayViewMat3 * vec3(dist, 0.0);\n  vec3 v_pos = u_dvsMat3 * vec3(a_pos.xy, 1.0) + offset;\n  vec3 pos = vec3(v_pos.xy, z);\n\n  applyFilter(v_color, pos, a_visible);\n\n  gl_Position = vec4(pos, 1.0);\n}\n"},text:{"text.frag":"precision lowp float;\n\nuniform lowp sampler2D u_texture;\n\nvarying mediump vec4 v_color;\nvarying mediump float v_antialiasingWidth;\nvarying mediump float v_edgeDistanceOffset;\nvarying mediump vec2 v_tex;\nvarying lowp float v_transparency;\n\n#ifdef ID\nvarying highp vec4 v_id;\n#endif // ID\n\nvoid main()\n{\n  // read the distance from the SDF texture\n  lowp float dist = texture2D(u_texture, v_tex).a;\n\n  // the edge distance if a factor of the outline width\n  // We cap this to 0.25 to prevent this from becomming negative / running into the glyph boundaries\n  float glyphEdgeDistance = max(0.75 - v_edgeDistanceOffset, 0.25);\n\n  #ifdef HIGHLIGHT\n    glyphEdgeDistance /= 2.0;\n  #endif\n\n  // use a smooth-step in order to calculate the geometry of the shape given by the distance field\n  lowp float alpha = smoothstep(glyphEdgeDistance - v_antialiasingWidth, glyphEdgeDistance + v_antialiasingWidth, dist) * v_transparency;\n\n  gl_FragColor = alpha * v_color;\n\n#ifdef ID\n  if (gl_FragColor.a < 1.0 / 255.0) {\n    discard;\n  }\n  gl_FragColor = v_id;\n#endif // ID\n}\n","text.vert":"precision mediump float;\n\n#include <materials/constants.glsl>\n#include <materials/utils.glsl>\n#include <materials/vv.glsl>\n#include <materials/effects.glsl>\n\nattribute vec2 a_pos;          // 2 * 2 (2 x signed 16)\nattribute vec4 a_id;           // 4 (4 x unsigned byte)\nattribute vec4 a_color;        // 4 (4 x unsigned byte)\nattribute vec2 a_vertexOffset; // 2 * 2 // (2 x signed 16) offset from the anchor point of the string\nattribute vec4 a_texFontSize;  // 4 (4 x unsigned byte) texture coordinatesm and font size\nattribute vec4 a_aux;          // hold onto additional information such as a bitset on the last byte (a_aux.w)\nattribute float a_visible;     // a one byte controlling the visibility of the vertex (a separate visibility buffer)\n\n#ifdef VV\nattribute highp vec4 a_vv;\n#endif\n\nuniform vec2 u_mosaicSize;\nuniform float u_pixelRatio;\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3; // Premultiplies DisplayMat3 * ViewMat3 * ScreenMat3\n\nvarying mediump vec4 v_color;\nvarying mediump float v_antialiasingWidth;\nvarying mediump float v_edgeDistanceOffset;\nvarying mediump vec2 v_tex;        // texture coordinates used to sample the glyph atlas\nvarying lowp float v_transparency; // the calculated transparency to be applied by the fragment shader. \n\n#ifdef ID\nvarying highp vec4 v_id;\n#endif // ID\n\nvoid main()\n{\n  float a_bitset = a_aux.w;\n\n  float isColorLocked = getBit(a_bitset, 0);\n  float isHalo = getBit(a_pos.x, 0);   // The lsb of pos denotes whether a vertex is part of the halo or not\n  float fontSize = a_texFontSize.z;\n  vec3 pos = vec3(floor(a_pos * 0.5), 1.0);\n  vec3 offset = vec3(a_vertexOffset * OFFSET_PRECISION, 0.0);\n  float scale = 1.0;\n\n  v_transparency = 1.0;\n  v_color = a_color;\n  v_tex = a_texFontSize.xy / u_mosaicSize;\n\n#ifdef ID\n  v_id = a_id;\n#endif\n\n#ifdef VV_OPACITY\n  v_transparency = getVVOpacity(a_vv.z);\n#endif\n\n#ifdef VV_COLOR\n  // we don't want to override the halo color\n  v_color = isHalo * a_color + (1.0 - isHalo) * getVVColor(a_vv.y, a_color, isColorLocked);\n#endif\n\n#ifdef VV_SIZE\n  float f = getVVSize(a_texFontSize.z, a_vv.x);\n  scale = f / fontSize; \n  fontSize = f;\n  offset.xy *= scale; \n#endif\n  \n#ifdef VV_ROTATION\n  offset = getVVRotationMat3(a_vv.w) * offset;\n#endif\n\n  vec3 v_pos = u_dvsMat3 * pos + u_displayMat3 * offset;\n  float fontScale = fontSize / SDF_FONT_SIZE;\n\n  // if isHalo is zero (not a halo) v_edgeDistanceOffset will end up being zero as well.\n  v_edgeDistanceOffset = isHalo * OUTLINE_SCALE * a_texFontSize.w / fontScale / MAX_SDF_DISTANCE;\n  v_antialiasingWidth = 0.105 * SDF_FONT_SIZE / fontSize / u_pixelRatio;\n\n  applyFilter(v_color, v_pos, a_visible);\n  \n  gl_Position = vec4(v_pos, 1.0);\n}\n"},"utils.glsl":"\nfloat getBit(in float bitset, in int bitIndex) {\n  float offset = pow(2.0, float(bitIndex));\n\n  return mod(floor(bitset / offset), 2.0);\n}\n","vv.glsl":"#if defined(VV_SIZE_MIN_MAX_VALUE) || defined(VV_SIZE_SCALE_STOPS) || defined(VV_SIZE_FIELD_STOPS) || defined(VV_SIZE_UNIT_VALUE)\n  #define VV_SIZE\n#endif\n\n#if defined(VV_COLOR) || defined(VV_SIZE) || defined(VV_OPACITY) || defined(VV_ROTATION)\n  #define VV\n#endif\n\n#ifdef VV_COLOR\nuniform highp float u_vvColorValues[8];\nuniform vec4 u_vvColors[8];\n#endif // VV_COLOR\n\n#ifdef VV_SIZE_MIN_MAX_VALUE\nuniform highp vec4 u_vvSizeMinMaxValue;\n#endif // VV_SIZE_MIN_MAX_VALUE\n\n#ifdef VV_SIZE_SCALE_STOPS\nuniform highp float u_vvSizeScaleStopsValue;\n#endif // VV_SIZE_SCALE_STOPS\n\n#ifdef VV_SIZE_FIELD_STOPS\nuniform highp float u_vvSizeFieldStopsValues[6];\nuniform float u_vvSizeFieldStopsSizes[6];\n#endif // VV_SIZE_FIELD_STOPS\n\n#ifdef VV_SIZE_UNIT_VALUE\nuniform highp float u_vvSizeUnitValueWorldToPixelsRatio;\n#endif // VV_SIZE_UNIT_VALUE\n\n#ifdef VV_OPACITY\nuniform highp float u_vvOpacityValues[8];\nuniform float u_vvOpacities[8];\n#endif // VV_OPACITY\n\n#ifdef VV_ROTATION\nuniform lowp float u_vvRotationType;\n#endif // VV_ROTATION\n\nconst highp float nanValue = 1e-30;\n\nbool isNan(float val) {\n  return (val == nanValue);\n  //return !( val < 0.0 || 0.0 < val || val == 0.0 );\n}\n\n#ifdef VV_SIZE_MIN_MAX_VALUE\nfloat getVVMinMaxSize(float sizeValue, float fallback) {\n  if (isNan(sizeValue)) {\n    return fallback;\n  }\n\n  // we need to multiply by 8 in order to translate to tile coordinates\n  float interpolationRatio = (sizeValue  - u_vvSizeMinMaxValue.x) / (u_vvSizeMinMaxValue.y - u_vvSizeMinMaxValue.x);\n  interpolationRatio = clamp(interpolationRatio, 0.0, 1.0);\n  return u_vvSizeMinMaxValue.z + interpolationRatio * (u_vvSizeMinMaxValue.w - u_vvSizeMinMaxValue.z);\n}\n#endif // VV_SIZE_MIN_MAX_VALUE\n\n#ifdef VV_SIZE_FIELD_STOPS\nconst int VV_SIZE_N = 6;\nfloat getVVStopsSize(float sizeValue, float fallback) {\n  if (isNan(sizeValue)) {\n    return fallback;\n  }\n\n  if (sizeValue <= u_vvSizeFieldStopsValues[0]) {\n    return u_vvSizeFieldStopsSizes[0];\n  }\n\n  for (int i = 1; i < VV_SIZE_N; ++i) {\n    if (u_vvSizeFieldStopsValues[i] >= sizeValue) {\n      float f = (sizeValue - u_vvSizeFieldStopsValues[i-1]) / (u_vvSizeFieldStopsValues[i] - u_vvSizeFieldStopsValues[i-1]);\n      return mix(u_vvSizeFieldStopsSizes[i-1], u_vvSizeFieldStopsSizes[i], f);\n    }\n  }\n\n  return u_vvSizeFieldStopsSizes[VV_SIZE_N - 1];\n}\n#endif // VV_SIZE_FIELD_STOPS\n\n#ifdef VV_SIZE_UNIT_VALUE\nfloat getVVUnitValue(float sizeValue, float fallback) {\n  if (isNan(sizeValue)) {\n    return fallback;\n  }\n\n  return u_vvSizeUnitValueWorldToPixelsRatio * sizeValue;\n}\n#endif // VV_SIZE_UNIT_VALUE\n\n#ifdef VV_OPACITY\nconst int VV_OPACITY_N = 8;\nfloat getVVOpacity(float opacityValue) {\n  if (isNan(opacityValue)) {\n    return 1.0;\n  }\n\n  if (opacityValue <= u_vvOpacityValues[0]) {\n    return u_vvOpacities[0];\n  }\n\n  for (int i = 1; i < VV_OPACITY_N; ++i) {\n    if (u_vvOpacityValues[i] >= opacityValue) {\n      float f = (opacityValue - u_vvOpacityValues[i-1]) / (u_vvOpacityValues[i] - u_vvOpacityValues[i-1]);\n      return mix(u_vvOpacities[i-1], u_vvOpacities[i], f);\n    }\n  }\n\n  return u_vvOpacities[VV_OPACITY_N - 1];\n}\n#endif // VV_OPACITY\n\n#ifdef VV_ROTATION\nmat4 getVVRotation(float rotationValue) {\n  // YF TODO: if the symbol has rotation we need to combine the symbo's rotation with the VV one\n  if (isNan(rotationValue)) {\n    return mat4(1, 0, 0, 0,\n                0, 1, 0, 0,\n                0, 0, 1, 0,\n                0, 0, 0, 1);\n  }\n\n  float rotation = rotationValue;\n  if (u_vvRotationType == 1.0) {\n    rotation = 90.0 - rotation;\n  }\n\n  float angle = C_DEG_TO_RAD * rotation;\n\n  float sinA = sin(angle);\n  float cosA = cos(angle);\n\n  return mat4(cosA, sinA, 0, 0,\n              -sinA,  cosA, 0, 0,\n              0,     0, 1, 0,\n              0,     0, 0, 1);\n}\n\nmat3 getVVRotationMat3(float rotationValue) {\n  // YF TODO: if the symbol has rotation we need to combine the symbo's rotation with the VV one\n  if (isNan(rotationValue)) {\n    return mat3(1, 0, 0,\n                0, 1, 0,\n                0, 0, 1);\n  }\n\n  float rotation = rotationValue;\n  if (u_vvRotationType == 1.0) {\n    rotation = 90.0 - rotation;\n  }\n\n  float angle = C_DEG_TO_RAD * -rotation;\n\n  float sinA = sin(angle);\n  float cosA = cos(angle);\n\n  return mat3(cosA, -sinA, 0,\n             sinA, cosA, 0,\n              0,    0,    1);\n}\n#endif // VV_ROTATION\n\n#ifdef VV_COLOR\nconst int VV_COLOR_N = 8;\n\nvec4 getVVColor(float colorValue, vec4 fallback, float isColorLocked) {\n  if (isNan(colorValue) || isColorLocked == 1.0) {\n    return fallback;\n  }\n\n  if (colorValue <= u_vvColorValues[0]) {\n    return u_vvColors[0];\n  }\n\n  for (int i = 1; i < VV_COLOR_N; ++i) {\n    if (u_vvColorValues[i] >= colorValue) {\n      float f = (colorValue - u_vvColorValues[i-1]) / (u_vvColorValues[i] - u_vvColorValues[i-1]);\n      return mix(u_vvColors[i-1], u_vvColors[i], f);\n    }\n  }\n\n  return u_vvColors[VV_COLOR_N - 1];\n}\n#endif // VV_COLOR\n\nfloat getVVSize(in float size, in float vvSize)  {\n\n#ifdef VV_SIZE_MIN_MAX_VALUE\n  return getVVMinMaxSize(vvSize, size);\n\n#elif defined(VV_SIZE_SCALE_STOPS)\n  return u_vvSizeScaleStopsValue;\n\n#elif defined(VV_SIZE_FIELD_STOPS)\n  return getVVStopsSize(vvSize, size);\n\n#elif defined(VV_SIZE_UNIT_VALUE)\n  return getVVUnitValue(vvSize, size);\n\n#else\n  return size;\n\n#endif\n}\n"},raster:{"solid.frag":"precision mediump float;\n\nvoid main(void) {\n  gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n}\n","texture.frag":"precision mediump float;\n\n// Texture coordinates.\nvarying vec2 v_texcoord;\n\n// Texture sampler.\nuniform sampler2D u_texture;\n\n// Opacity.\nuniform float u_opacity;\n\nvoid main(void) {\n  vec4 color = texture2D(u_texture, v_texcoord);\n  color.a *= u_opacity;\n  gl_FragColor = vec4(color.rgb * color.a, color.a);\n}\n","transform.vert":"precision mediump float;\n\n// Vertex position. Assumed normalized in the [0, 1] range.\nattribute vec2 a_position;\n\n// Transform matrix.\nuniform mat4 u_transform;\n\n// Output texture coordinates, for interpolation.\nvarying vec2 v_texcoord;\n\nvoid main(void) {\n  gl_Position = u_transform * vec4((2.0 * a_position - 1.0), 0.0, 1.0);\n  v_texcoord = a_position;\n}\n"},stencil:{"stencil.frag":"void main() {\n  gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);\n}\n","stencil.vert":"attribute vec2 a_pos;\n\nvoid main() {\n  gl_Position = vec4(a_pos, 0.0, 1.0);\n}\n"},tileInfo:{"tileInfo.frag":"uniform mediump sampler2D u_texture;\nvarying mediump vec2 v_tex;\n\nvoid main(void) {\n  lowp vec4 color = texture2D(u_texture, v_tex);\n  gl_FragColor = 0.75 * color;\n}\n","tileInfo.vert":"attribute vec2 a_pos;\n\nuniform highp mat3 u_dvsMat3;\n\nuniform mediump float u_depth;\nuniform mediump float u_coord_ratio;\nuniform mediump vec2 u_delta; // in tile coordinates\nuniform mediump vec2 u_dimensions; // in tile coordinates\n\nvarying mediump vec2 v_tex;\n\nvoid main() {\n  mediump vec2 offset = u_coord_ratio * vec2(u_delta + a_pos * u_dimensions);\n  vec3 v_pos = u_dvsMat3 * vec3(offset, 1.0);\n  \n  gl_Position = vec4(v_pos.xy, 0.0, 1.0);\n\n  v_tex = a_pos;\n}\n"},util:{"encoding.glsl":"// Factors to convert rgba back to float\nconst vec4 rgba2float_factors = vec4(\n    255.0 / (256.0),\n    255.0 / (256.0 * 256.0),\n    255.0 / (256.0 * 256.0 * 256.0),\n    255.0 / (256.0 * 256.0 * 256.0 * 256.0)\n  );\n\nfloat rgba2float(vec4 rgba) {\n  // Convert components from 0->1 back to 0->255 and then\n  // add the components together with their corresponding\n  // fixed point factors, i.e. (256^1, 256^2, 256^3, 256^4)\n  return dot(rgba, rgba2float_factors);\n}\n"}}});